А теперь кратко-рецептурно и конкретно =)

v3.2.0 привносит строгое оформление с помощью богатых возможностей [css-variables](https://dev.to/idoshamun/theming-with-css-variables-322f)
и разделения селекторов на "контекстные" и "основные/индексные".

## i-am-css v3.2.0
Разделять слова многословных атрибутов и их значений следует символом `-`,
набор модификаторов в виде значения атрибута пишется через пробел.

Всё необходимое css-оформление указываются в "основном" ("index") селекторе элемента через css-переменные,
без указания модификаторов, тем самым открывая "интерфейс" к своему оформлению.
Оформление, зависящее от модификатора, указывается в "контекстном" селекторе размещённом ранее
(соответствующие стили необходимо включать раньше стилей компонент),
в нём указывается значение css-переменной из списка перечисленных переменных в "основном" селекторе.
В контекстных селекторах размещаются только! значения css-переменных, другие css-свойства указывать запрещено.
"Основные селекторы" могут быть одновременно контекстом для примиксованных "основных",
потому содержать и определения переменных и обычные css-свойства.

Например:
```css
/* iam-themes на корневой html-элемент.
Этот способ не рекомендуется - лучше подключать просто нужный файл темы thm-simple.css */
[iam-themes ~= "thm-simple"] {
	--popup-header-back-color: #ccc;
}

/* контекстный/модифицирующий селектор со значением переменных */
[iam-popup-header ~= "warn"] {
	--popup-header-back-color: red;
}

/* "Основной" селектор элемента header блока popup */
[iam-popup-header] {
	background-color: var(--popup-header-back-color, transparent);
}
```

Необходимо учитывать тот момент, что компоненты могут быть вложены иерархически,
потому такой код, при иерархии collapser'ов по динамически изменяемым модификаторам,
сработает некорректно - все кнопки будут показывать то состояние, чей контекстный селектор,
при соответствующем модификаторе в атрибуте одного из iam-collapser'ов определён последним:
```css
/* контекстный селектор */
[iam-collapser ~= "is-open:0"] {
	--iam-collapser-btn-symbol: "\25be";
	--iam-collapser-content-area-display: none;
}

/* контекстный селектор */
[iam-collapser ~= "is-open:1"] {
	--iam-collapser-btn-symbol: "\25b4";
	--iam-collapser-content-area-display: block;
}

/* основной селектор элемента btn */
[iam-collapser-btn]::after {
	content: var(--iam-collapser-btn-symbol);
}

/* основной селектор элемента content-area */
[iam-collapser-content-area] {
	display: var(--iam-collapser-content-area-display);
}
```

В "основном" селекторе элемента допустимо прописывать fallback'и на случай отсутствия определения переменнойе.
Считается, что css-переменные обязательно поддерживаются браузером клиента, иначе iAMcss v3 использовать не стоит.

## Выбор html-элементов
Выбор тэга, на который вешается iam-атрибут рекомендуется основывать на идеологии "naked css"
(когда стили и скрипты не подгрузились) и, до определённой степени, семантичен
(для альтернативных устройств чтения контента). Как минимум чтобы можно было отправить содержимое
страницы на печать и затем эту информацию удобно было бы считывать.
Строго запрещено CSS-правила подвязывать на базовые html-элементы - всё что требует оформления,
должно быть помечено iam-атрибутом.

## "Элементы элементов" или "Решение основной засады БЭМ"
Сами БЭМеры используют понятие "[БЭМ головного мозга](https://ru.bem.info/forum/-233/)" (когда во всём видят БЭМ), по мне так
это потеря видения исходной задачи и сакрализация БЭМ как де-факто!

Принцип разделения на блоки и элементы в Яндексе преследовал цель логической группировки элементов,
чтобы навести порядок на полках. Но на самом деле нет технической необходимости разделять понятия
блок и элемент, этот процесс лишь усложняет вёрстку и требует дополнительных затрат времени
на принятие решений.

В DOM "блок" умозрительная вещь, а "элемент" конкретная! =)
Потому все iam-атрибуты это прежде всего атрибуты элементов для возможного размещения в них модификаторов.
Принадлежность конкретному блоку следует из наименования атрибута.
Как и в БЭМ, дерево вложенности элементов в блоки может не совпадать с DOM, т.е. быть сквозным,
не наращивая "жирок" наименования от промежуточных dom-элементов.

В v3 принадлежность элемента конкретному блоку видна из синтаксиса - иерархического названия элемента.
Корневой элемент блока обозначается просто наименованием блока.
Дочерние элементы блока содержат в атрибуте сначала имя блока, затем своё имя не обособляя нотацию
именования разделителями типа "__" или "--", соответственно сливаются с блоком через "-".

## Именование/синтаксис iam-атрибутов
Все наименования, состоящие из нескольких слов, должны быть совместимы с правилами
наименований xml-атрибутов, используется cebab-case.

Как только в CSS получаем коллизии со специфичностью правил, так сразу следует соответствующие атрибуты
переименовать, включив в наименование соответствующий модификатор/элемент, чтобы снизить специфичность!
[Например](https://github.com/viT-1/iAMcss-samples/commit/4bcecb8d9f85b9bd9c80e4d5725ca96d2cc2ddfa#diff-d2417633265dabe7f8af98f48f14baa438357746325a9d79ba17ecbf344001a1)

## Содержимое iam-атрибутов - модификаторы
Допустимо не иметь ни единого модификатора, тогда iam-атрибут пуст.

Значение атрибута содержит только модификаторы, в число которых, при необходимости,
входят отсылки на родительские блоки любого уровня вложенности.

У блоков не бывает модификаторов? Бывают! Должны быть определены как контекстные селекторы (ранее элементов),
и содержать значения переменных для зависимых от этого модификатора элементов блока.

Если модификатор динамически не меняется, есть смысл подумать о переносе имени модификатора
из значения iam-атрибута в его наименование.

В основном используется атрибутивный селектор ~=, который позволяет вычислять строки разделённые пробелами,
но для комбинации соседних, чтобы не повышать специфичность перечислением `[att  ~= m1][att ~= m2]`,
иногда приходится использовать селектор `*=`, например: `[att *= "m1 m2"]`

Также допускаются модификаторы с двоеточием, например: `[list-item ~= "is-open:true"]`

В общем случае модификаторы могут занимать в значении атрибута любое место,
соответственно мы не можем рассчитывать, что он будет в начале или в конце значения атрибута.
При этом остаётся возможность использовать парные модификаторы, которые точно соседствуют,
но такое использование может привести к ошибкам (пофиксить которые можно множественным атриюутивным селектором с ~=).

Обычно новым блоком оформляются компоненты имеющие уникальный функционал.
Если отличия двух dom-элементов, находящихся в родительском блоке, минимальны,
и только затрагивают визуальную часть (по вёрстке одинаковы), то,
вместо разных iam-атрибутов, можно указывать один и тот же, но с разным модификатором, например:
```html
<div iam-links>
	<ul iam-plain-list="breadcrumbs" iam-links-list>
		<li iam-plain-list-item="breadcrumbs"><a iam-link href="/articles">Статьи</a></li>
		<li iam-plain-list-item="breadcrumbs"><a iam-link href="/articles/css">CSS</a></li>
		<li iam-plain-list-item="breadcrumbs"><a iam-link href="/articles/css/iamcss">iAMCss</a></li>
		<li iam-plain-list-item="breadcrumbs">3.1.2</li>
	</ul>
	<ul iam-plain-list iam-links-list="main">
		<li iam-plain-list-item><a iam-link="main" href="/articles">Статьи</a></li>
		<li iam-plain-list-item><a iam-link="main" href="/social">Контакты</a></li>
		<li iam-plain-list-item><a iam-link="main" href="/price">Цены</a></li>
	</ul>
</div>
```
```css
[iam-links] {
  --iam-links-font-size: 16px;
  --iam-links-list-padding: calc(var(--iam-links-font-size)/2) var(--iam-links-font-size);
}

/* <iam-plain-list-item--breadcrumbs> */
[iam-plain-list-item ~= breadcrumbs]:after {
	--iam-plain-list-item-after-content: ">";
	--iam-plain-list-item-after-margin: 0;
	--iam-plain-list-item-after-padding: 0 calc(var(--iam-links-font-size)/2);
}
/* </iam-plain-list-item--breadcrumbs> */

/* <iam-plain-list> */
[iam-plain-list] {
	--iam-plain-list-margin: 0;
	--iam-plain-list-padding: 0;
  
	--iam-plain-list-item-display: inline-block;
}

[iam-plain-list-item]:last-child {
	--iam-plain-list-item-after-display: none;
}

[iam-plain-list] {
	font-size: 0;
	margin: var(--iam-plain-list-margin);
	padding: var(--iam-plain-list-padding);
}

[iam-plain-list-item] {
	font-size: var(--iam-links-font-size);
	display: var(--iam-plain-list-item-display);
}

[iam-plain-list-item]:after {
	content: var(--iam-plain-list-item-after-content);
	display: var(--iam-plain-list-item-after-display);
	margin: var(--iam-plain-list-item-after-margin);
	padding: var(--iam-plain-list-item-after-padding);
}
/* </iam-plain-list> */

/* <iam-links--main> */
[iam-links-list ~= main] {
	--iam-link-border-right: solid 1px LinkText;
	--iam-links-list-padding: calc(var(--iam-links-font-size)/2) var(--iam-links-font-size) calc(var(--iam-links-font-size)/2) 0;
}

[iam-link ~= main] {
	--iam-link-padding: 0 var(--iam-links-font-size);
}
/* </iam-links--main> */

/* <iam-links> */
[iam-links-list] {
	padding: var(--iam-links-list-padding);
  
	background: #eee;
	display: block;
	margin-bottom: var(--iam-links-font-size);
}

/* should be "iam-links-list-item" */
[iam-plain-list-item]:last-child {
	--iam-link-border-right: unset transparent;
}

[iam-link] {
	padding: var(--iam-link-padding);
	border-right: var(--iam-link-border-right);
}
/* </iam-links> */
```

### Контекстный селектор одного из родительских блоков (ancestors)
i-am-css позволяет уменьшить [специфичность](https://developer.mozilla.org/ru/docs/Web/CSS/Specificity) от иерархичности селекторов, размещая контекст в рамках скобок "[]", а не через пробел, например указывая вложенность как контекст блока: `[iam-p ~= iam-article]`.

Если всё же требуется написать "контекстный" селектор через пробел (например, чтобы учесть два контекста сразу),
то оканчиваться он должен (за исключением псевдоэлементов и стандартных состояний типа `:disabled`) атрибутивным i-am-css селектором,
а не именем тэга или *.
При первой же возможности рекомендуется отрефакторить код с "пробельными" селекторами, например [так](https://github.com/viT-1/iAMcss-samples/commit/4bcecb8d9f85b9bd9c80e4d5725ca96d2cc2ddfa).

В общем смысле рефакторинг пробельных селекторов заключается в определении более специфичных переменных.
Например при требуется для динамического модификатора (state) задать второй контекст - тему:
```css
[iam-collapser ~= "is-open:0"] {
	--iam-collapser-btn-symbol: "\25be";
	--iam-collapser-content-area-display: none;
}
```
Рефакторим в:
```css
[iam-themes ~= "thm-simple"] {
	--iam-collapser-btn-symbol-closed: "\25be";
	--iam-collapser-btn-symbol-open: "\25b4";
}

[iam-collapser ~= "is-open:0"] {
	--iam-collapser-btn-symbol: var(--iam-collapser-btn-symbol-closed);
	--iam-collapser-content-area-display: none;
}
```
Тогда `--iam-collapser-btn-symbol-closed` и	`--iam-collapser-btn-symbol-open` возможно будет
переопределить не повышая специфичность, но надо будет думать, в каком порядке соответствующие
селекторы будут подключены.

Основные же индексные селекторы должны определяться строго минимально без пробелов: `[...]`

## iam-атрибуты-модификаторы
Идея почерпнута [отсюда](https://github.com/amcss/attribute-module-specification/issues/29).
При желании, особенно если хочется разделить модификаторы по небольшим кучкам,
вплоть до того, что в значении атрибута размещать только одно значение модификатора,
возожно замиксовать их все раздельно, но тогда вёрстка станет столь же многословной как БЭМ!

## Компонентный подход (vue- web- и прочие)
Компонентный подход подразумевает, что все элементы блока доступны только внутри компонента, но не в общей вёрстке. При компонентном подходе не получится миксовать компоненты, но миксы на некомпонентых элементах по прежнему будут доступны.

Если используются компоненты, то наименование блока становится html-элементом, а все его модификаторы передаются как отдельные атрибуты, с последующим рендерингом в обычную вёрстку по iamCSS.

[Поддержка браузеров](https://caniuse.com/css-variables) и [полифил](https://github.com/nuxodin/ie11CustomProperties) для IE11.