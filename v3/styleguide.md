А теперь кратко-рецептурно и конкретно =)

v3.1.2 для передачи [родительского контекста](../styleguide.md#родительский-контекст) используются
модификаторы совпадающие с именованием любого блок-элемента стоящего выше по дереву DOM.
CSS-переменные не используются, что позволяет поддерживать браузеры ещё не понимающие их.

v3.2.0 привносит строгое оформление с помощью богатых возможностей [css-variables](https://dev.to/idoshamun/theming-with-css-variables-322f)
Введены понятия, разделяющие селекторы на "контекстные/модификации" и "основные/индексные".
CSS-свойства элементов блока могут содержать css-переменные и быть переопределены
не только контекстом модификации элемента, но и контекстом любого блока (и их модификаций).
Для ie11 возможна поддержка с помощью
- [ie11-custom-properties](https://github.com/nuxodin/ie11CustomProperties)
- [css-vars-ponyfill](https://github.com/jhildenbiddle/css-vars-ponyfill)

v3.2.1 становится возможным передать контекст вниз по иерархии с помощью [space-toggler](https://github.com/propjockey/css-sweeper#basics-of-space-toggle), позволяя всю логику разместить поближе к основному (index) селектору.
Способ неоднозначный, поскольку если следовать принципам ООП, то любой чёрный ящик не должен знать,
какие чёрные ящики есть снаружи него.

## iam-css v3.2.1
Разделять слова многословных атрибутов и их значений следует символом `-`,
набор модификаторов в виде значения атрибута пишется через пробел.

В вёрстке, в качестве значения атрибута, в отличии от предыдущих версий iam-css,
нет смысла указывать родительскиие iam-block, так как можно задать значения переменных
для дочерних блоков в "контекстном" селекторе `[iam-parent-block]`, а не в `[iam-another-block ~= iam-parent-block]`.

Всё необходимое css-оформление указываются в "основном" ("index") селекторе элемента через css-переменные,
без указания модификаторов, тем самым открывая "интерфейс" к своему оформлению.
Оформление, зависящее от модификатора, указывается в "контекстном" селекторе размещённом позже индексного.
Хоть даже при одинаковой специфичности контекст (передаваемый через css-переменные) разрешён будет корректно,
вне зависимости от порядка определения "контекстного" и "базового" селектора в css-файле, "контекстный" селектор
следует размещать ниже "базового", чтобы возможно было корректно переопределять css-свойства и без css-переменных.

Для большей строгости кода, в контекстных селекторах рекомендуется размещать только! значения css-переменных.
"Базовые селекторы" могут быть одновременно контекстом для других "базовых" примиксованных,
потому могут содержать как определения переменных, так и обычные css-свойства.

Например:
```css
/*	iam-themes на корневой html-элемент.
**	Этот способ не рекомендуется - лучше подключать просто нужный файл темы thm-simple.css
**	напрямую, либо через @import
*/
[iam-themes ~= "thm-simple"] {
	--popup-header-back-color: #ccc;
}

/*	контекстный селектор (селектор-модификация) со значением переменных */
[iam-popup-header ~= "v-warn"] {
	--popup-header-back-color: red;
}

/*	"Базовый/основной/index" селектор элемента header блока popup */
[iam-popup-header] {
	background-color: var(--popup-header-back-color, transparent);
}
```

Необходимо учитывать тот момент, что компоненты могут быть вложены иерархически,
потому такой код, при иерархии collapser'ов по динамически изменяемым модификаторам,
сработает некорректно - все кнопки будут показывать то состояние, чей контекстный селектор,
при соответствующем модификаторе в атрибуте одного из iam-collapser'ов определён последним:
```css
/*	контекстный селектор (селектор-модификация) */
[iam-collapser ~= "is-open:1"] {
	--iam-collapser-is-open: ;
}

/*	внезапно контекстный (поскольку для элементов блока он родительский) селектор */
[iam-collapser] {
	--iam-collapser-open-btn-symbol: var(--iam-collapser-is-open) "\25b4";
	--iam-collapser-btn-symbol: var(--iam-collapser-open-btn-symbol, "\25be");

	--iam-collapser-content-area-open-display: var(--iam-collapser-is-open) block;
	--iam-collapser-content-area-display: var(--iam-collapser-content-area-open-display, none);
}

/*	основной селектор элемента btn */
[iam-collapser-btn]::after {
	content: var(--iam-collapser-btn-symbol);
}

/*	основной селектор элемента content-area */
[iam-collapser-content-area] {
	display: var(--iam-collapser-content-area-display);
}
```

В "основном" селекторе элемента допустимо прописывать fallback'и на случай отсутствия определения переменной (не забываем initial).
Считается, что css-переменные обязательно поддерживаются браузером клиента, иначе iAMcss v3.2 использовать не стоит.

## Выбор html-элементов
Выбор тэга, на который вешается iam-атрибут рекомендуется основывать на идеологии "naked css"
(когда стили и скрипты не подгрузились) и, учитывать семантичность (для альтернативных устройств чтения контента).
Корректность семантичности можно определить удобством считывания информации, распечатанной (naked css) страницы на принтере,
а ещё лучше при помощи какого-нибудь screen-reader'а.
Строго запрещено селекторы подвязывать на базовые html-элементы - всё что требует оформления,
должно быть помечено iam-атрибутом.

## "Элементы элементов" или "Решение основной засады БЭМ"
Сами БЭМеры используют понятие "[БЭМ головного мозга](https://ru.bem.info/forum/-233/)" (когда во всём видят БЭМ), по мне так
это потеря видения исходной задачи и сакрализация БЭМ де-факто!

Принцип разделения на блоки и элементы в Яндексе преследовал цель логической группировки элементов,
чтобы навести порядок на полках. Но на самом деле нет технической необходимости разделять понятия
блок и элемент, этот процесс лишь усложняет вёрстку и требует дополнительных затрат времени
на принятие решений.

В DOM "блок" умозрительная вещь, а "элемент" конкретная! =)
Потому все iam-атрибуты это прежде всего атрибуты элементов для возможного размещения в них модификаторов.
Принадлежность конкретному блоку следует из наименования атрибута.
Как и в БЭМ, дерево вложенности элементов в блоки может не совпадать с DOM, т.е. быть сквозным,
не наращивая "жирок" наименования от промежуточных dom-элементов.

В v3 принадлежность элемента конкретному блоку видна из синтаксиса - иерархического названия элемента.
Корневой элемент блока обозначается просто наименованием блока.
Дочерние элементы блока содержат в атрибуте сначала имя блока, затем своё имя не обособляя нотацию
именования разделителями типа "__" или "--", соответственно сливаются с блоком через "-".

## Именование/синтаксис iam-атрибутов
Все наименования, состоящие из нескольких слов, должны быть совместимы с правилами
наименований xml-атрибутов, используется cebab-case.

Как только в CSS получаем коллизии со специфичностью правил, так сразу следует соответствующие атрибуты
переименовать, включив в наименование соответствующий модификатор/элемент, чтобы снизить специфичность!
[Например](https://github.com/viT-1/iAMcss-samples/commit/4bcecb8d9f85b9bd9c80e4d5725ca96d2cc2ddfa#diff-d2417633265dabe7f8af98f48f14baa438357746325a9d79ba17ecbf344001a1)
плюс [переход на v3.2.1](https://github.com/viT-1/iAMcss-samples/commit/2a3c42fa137436d33eb8a1fc74a65d649ddab564) с использованием space-toggler.

## Содержимое iam-атрибутов - модификаторы
Допустимо не иметь ни единого модификатора, тогда iam-атрибут будет пуст.

Значение атрибута содержит только состояния (states) и представления (views).
Поскольку состояния относятся к конкретному элементу, а он всегда в единственном числе,
то рекомендуется подчеркнуть, что этот модификатор динамичен, предвариев его имя префиксом `is-`.
Views предварять `v-` особо смысла нет.

У блоков не бывает модификаторов? У самих блоков нет, но есть корневой элемент блока,
именованный только именем блока, и есть контекстные (в том числе родительские) переключатели (context togglers).

Если модификатор динамически не меняется, то, возможно это view и есть смысл подумать о переносе имени модификатора
из значения iam-атрибута в его наименование.

В основном используется атрибутивный селектор ~=, который позволяет вычислять строки разделённые пробелами,
но для комбинации соседних, чтобы не повышать специфичность перечислением `[att  ~= m1][att ~= m2]`,
иногда приходится использовать селектор `*=`, например: `[att *= "m1 m2"]`

Также допускаются модификаторы с двоеточием, например: `[list-item ~= "is-open:true"]`

В общем случае модификаторы могут занимать в значении атрибута любое место,
соответственно мы не можем рассчитывать, что он будет в начале или в конце значения атрибута.
При этом остаётся возможность использовать парные модификаторы, которые точно соседствуют,
но такое использование может привести к ошибкам (пофиксить которые можно множественным атриюутивным селектором с ~=).

Обычно новым блоком оформляются компоненты имеющие уникальный функционал.
Если отличия двух dom-элементов, находящихся в родительском блоке, минимальны,
и только затрагивают визуальную часть (по вёрстке одинаковы), то,
вместо разных iam-атрибутов, можно указывать один и тот же, но с разным модификатором, например:
```html
<div iam-links>
	<ul iam-plain-list="breadcrumbs" iam-links-list>
		<li iam-plain-list-item="breadcrumbs"><a iam-link href="/articles">Статьи</a></li>
		<li iam-plain-list-item="breadcrumbs"><a iam-link href="/articles/css">CSS</a></li>
		<li iam-plain-list-item="breadcrumbs"><a iam-link href="/articles/css/iamcss">iAMCss</a></li>
		<li iam-plain-list-item="breadcrumbs">3.1.2</li>
	</ul>
	<ul iam-plain-list iam-links-list="main">
		<li iam-plain-list-item><a iam-link="main" href="/articles">Статьи</a></li>
		<li iam-plain-list-item><a iam-link="main" href="/social">Контакты</a></li>
		<li iam-plain-list-item><a iam-link="main" href="/price">Цены</a></li>
	</ul>
</div>
```
```css
[iam-links] {
  --iam-links-font-size: 16px;
  --iam-links-list-padding: calc(var(--iam-links-font-size)/2) var(--iam-links-font-size);
}

/* <iam-plain-list-item--breadcrumbs> */
[iam-plain-list-item ~= breadcrumbs]:after {
	--iam-plain-list-item-after-content: ">";
	--iam-plain-list-item-after-margin: 0;
	--iam-plain-list-item-after-padding: 0 calc(var(--iam-links-font-size)/2);
}
/* </iam-plain-list-item--breadcrumbs> */

/* <iam-plain-list> */
[iam-plain-list] {
	--iam-plain-list-margin: 0;
	--iam-plain-list-padding: 0;
  
	--iam-plain-list-item-display: inline-block;
}

[iam-plain-list-item]:last-child {
	--iam-plain-list-item-after-display: none;
}

[iam-plain-list] {
	font-size: 0;
	margin: var(--iam-plain-list-margin);
	padding: var(--iam-plain-list-padding);
}

[iam-plain-list-item] {
	font-size: var(--iam-links-font-size);
	display: var(--iam-plain-list-item-display);
}

[iam-plain-list-item]:after {
	content: var(--iam-plain-list-item-after-content);
	display: var(--iam-plain-list-item-after-display);
	margin: var(--iam-plain-list-item-after-margin);
	padding: var(--iam-plain-list-item-after-padding);
}
/* </iam-plain-list> */

/* <iam-links--main> */
[iam-links-list ~= main] {
	--iam-link-border-right: solid 1px LinkText;
	--iam-links-list-padding: calc(var(--iam-links-font-size)/2) var(--iam-links-font-size) calc(var(--iam-links-font-size)/2) 0;
}

[iam-link ~= main] {
	--iam-link-padding: 0 var(--iam-links-font-size);
}
/* </iam-links--main> */

/* <iam-links> */
[iam-links-list] {
	padding: var(--iam-links-list-padding);
  
	background: #eee;
	display: block;
	margin-bottom: var(--iam-links-font-size);
}

/* should be "iam-links-list-item" */
[iam-plain-list-item]:last-child {
	--iam-link-border-right: unset transparent;
}

[iam-link] {
	padding: var(--iam-link-padding);
	border-right: var(--iam-link-border-right);
}
/* </iam-links> */
```

### Контекстный селектор одного из родительских блоков (ancestors)
iam-css позволяет уменьшить [специфичность](https://developer.mozilla.org/ru/docs/Web/CSS/Specificity) от иерархичности селекторов, размещая контекст в рамках скобок "[]", а не через пробел, например указывая вложенность как контекст блока: `[iam-p ~= iam-article]`.
Но можно прописывать контексты проще, за счёт сохранения значений в контексте css-переменных, например:
```css
[iam-article] {
	--iam-p-font-size: 14px;
}

[iam-p] {
	font-size: var(--iam-p-font-size);
}
```

Точно также в v3.2 можно избавиться от таких составных модификаторов v3.1 как `[iam-h *= "iam-article h1"]`, например:
```css
:root {
	--iam-h1-font-size: 20px;
}

[iam-article] {
	--iam-h1-font-size: 14px;
}

[iam-h ~= h1] {
	--iam-h-font-size: var(--iam-h1-font-size);

	/* вместо :root можно указывать базовое значение прямо здесь */
	--iam-h-font-size: var(--iam-h1-font-size, 20px);
}

[iam-h] {
	font-size: var(--iam-h-font-size);
}
```
либо с применением техники [toggler](https://github.com/propjockey/css-sweeper#basics-of-space-toggle)'а
```css
[iam-article] {
	--iam-article--: ;
}

[iam-h ~= h1] {
	--iam-article-h-font-size: var(--iam-article--) 14px;
	--iam-h-font-size: var(--iam-article-h-font-size, 20px);
}

[iam-h ~= h2] {
	--iam-article-h-font-size: var(--iam-article--) 12px;
	--iam-h-font-size: var(--iam-article-h-font-size, 18px);
}

[iam-h] {
	font-size: var(--iam-h-font-size);
}

```

Если всё же требуется написать "контекстный" селектор через пробел (например, чтобы учесть два контекста сразу),
то оканчиваться он должен (за исключением псевдоэлементов и стандартных состояний типа `:disabled`) атрибутивным iam-css селектором,
а не именем тэга или *.
При первой же возможности рекомендуется отрефакторить код с "пробельными" селекторами, например [так](https://github.com/viT-1/iAMcss-samples/commit/4bcecb8d9f85b9bd9c80e4d5725ca96d2cc2ddfa).

В общем смысле рефакторинг пробельных селекторов заключается в определении более специфичных переменных.
Например при требуется для динамического модификатора (state) задать второй контекст - тему:
```css
[iam-collapser ~= "is-open:0"] {
	--iam-collapser-btn-symbol: "\25be";
	--iam-collapser-content-area-display: none;
}
```
Рефакторим в:
```css
[iam-themes ~= "thm-simple"] {
	--iam-collapser-btn-symbol-closed: "\25be";
	--iam-collapser-btn-symbol-open: "\25b4";
}

[iam-collapser ~= "is-open:0"] {
	--iam-collapser-btn-symbol: var(--iam-collapser-btn-symbol-closed);
	--iam-collapser-content-area-display: none;
}
```
Тогда `--iam-collapser-btn-symbol-closed` и	`--iam-collapser-btn-symbol-open` возможно будет
переопределить не повышая специфичность, но надо будет думать, в каком порядке соответствующие
селекторы будут подключены.

Основные же индексные селекторы должны определяться строго минимально без пробелов: `[...]`

## iam-атрибуты-модификаторы
Идея почерпнута [отсюда](https://github.com/amcss/attribute-module-specification/issues/29).
При желании, особенно если хочется разделить модификаторы по небольшим кучкам,
вплоть до того, что в значении атрибута размещать только одно значение модификатора,
возможно замиксовать их все раздельно, но тогда вёрстка станет столь же многословной как БЭМ!

## Компонентный подход (vue- web- и прочие)
Компонентный подход подразумевает, что все элементы блока доступны только внутри компонента, но не в общей вёрстке.
При компонентном подходе не получится миксовать компоненты, но миксы на некомпонентых элементах по прежнему будут доступны.

Если используются компоненты, то наименование блока становится html-элементом, а все его модификаторы передаются как отдельные атрибуты, с последующим рендерингом в обычную вёрстку по iam-css.

[Поддержка браузеров](https://caniuse.com/css-variables) и [полифил](https://github.com/nuxodin/ie11CustomProperties) для IE11.