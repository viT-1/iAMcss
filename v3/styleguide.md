# iAMcss 3.0
А теперь кратко-рецептурно и конкретно =)

## v3.1
Для удобства копирования и меньшего количества символов в селекторах
разделять слова принято символом "_",
а в качестве разделителей модификаторов использовать вместо фигурных скобок символ "-".
[Пример](https://github.com/viT-1/iAMcss/blob/master/v3/samples/quote/quote.htm)[html](https://htmlpreview.github.io/?https://github.com/viT-1/iAMcss/blob/bcc0fe47e208f50598e65b624e3be30fe0ff4f06/v3/samples/quote/quote.htm)

## Выбор html-элементов
Выбор тэга, на который вешается iam-атрибут рекомендуется основывать на идеологии "naked css"
(когда стили и скрипты не подгрузились) и, до определённой степени, семантичен
(для альтернативных устройств чтения контента). Как минимум чтобы можно было отправить содержимое
страницы на печать и затем эту информацию удобно было бы считывать.
Строго запрещено CSS-правила подвязывать на базовые html-элементы - всё что требует оформления,
должно быть помечено iam-атрибутом.

## "Элементы элементов" или "Решение основной засады БЭМ"
Сами БЭМеры используют понятие "[БЭМ головного мозга](https://ru.bem.info/forum/-233/)" (когда во всём видят БЭМ), по мне так
это потеря видения исходной задачи и сакрализация БЭМ как де-факто!

Принцип разделения на блоки и элементы в Яндексе преследовал цель логической группировки элементов,
чтобы навести порядок на полках. Но на самом деле нет технической необходимости разделять понятия
блок и элемент, этот процесс лишь усложняет вёрстку и требует дополнительных затрат времени
на принятие решений.

В DOM "блок" умозрительная вещь, а "элемент" конкретная! =)
Потому все iam-атрибуты это прежде всего атрибуты элементов для возможного размещения в них модификаторов.
Принадлежность конкретному блоку следует из наименования атрибута.
Как и в БЭМ, дерево вложенности элементов в блоки может не совпадать с DOM, т.е. быть сквозным,
не наращивая "жирок" наименования от промежуточных dom-элементов.

В 3.0 принадлежность элемента конкретному блоку видна из синтаксиса - иерархического названия элемента.
Корневой элемент блока обозначается просто наименованием блока.
Дочерние элементы блока содержат в атрибуте сначала имя блока, затем своё имя не обособляя нотацию
именования разделителями типа "__" или "--", соответственно сливаются с блоком через "-".

## Именование/синтаксис iam-атрибутов
Все наименования, состоящие из нескольких слов, должны быть совместимы с правилами
наименований xml-атрибутов, используется cebab-case.

Как только в CSS получаем коллизии со специфичностью правил, так сразу следует соответствующие атрибуты
переименовать, включив в наименование соответствующий модификатор/элемент, чтобы снизить специфичность!

## Содержимое iam-атрибутов - модификаторы
Допустимо не иметь ни единого модификатора, тогда iam-атрибут пуст.

Значение атрибута содержит только модификаторы, в число которых, при необходимости,
входят ссылки на родительские блоки любого уровня вложенности.

У блоков не бывает модификаторов? Бывают, вопрос лишь в том, где их размещать.
Модификатор блока подразумевает использование стилей исходного блока,
иначе это новый блок и iam-атрибут должен иметь другое название.
Модификатор блока должен быть в качестве модификатора каждого элемента блока, в том числе корневого.
Если модификатор динамически не меняется, есть смысл подумать о переносе имени модификатора
из значения iam-атрибута в его наименование.

Модификаторы, кроме контекстов родительских блоков, могут иметь либо просто префикс "m" (modificator),
либо "v" (view), либо "s" (state), либо классический "-" (получается {--open}), а могут и не иметь вообще.

Любой модификатор, в том числе контекст родительского блока обрамляется в фигурные скобки,
чтобы исключить частичное совпадение по *=. Между фигурными скобками нет нужды в пробелах!
Если в качестве разделителя (без пробелов) использовать символ "_", то в атрибутивных селекторах
возможно будет опустить кавычки, но это по вкусу...

В общем случае модификаторы могут занимать в значении атрибута любое место,
соответственно мы не можем рассчитывать, что он будет в начале или в конце значения атрибута.
При этом остаётся возможность использовать парные модификаторы, которые точно соседствуют.

Обычно новым блоком оформляются компоненты имеющие уникальный функционал.
Если отличия двух dom-элементов, находящихся в родительском блоке, минимальны,
и только затрагивают визуальную часть (по вёрстке одинаковы), то,
вместо разных iam-атрибутов, можно указывать один и тот же, но с разным модификатором, например:
```html
<div iam-links>
	<ul iam-plain-list="{--breadcrumbs}" iam-links-list="">
		<li iam-plain-list-item="{--breadcrumbs}"><a iam-link href="/articles">Статьи</a></li>
		<li iam-plain-list-item="{--breadcrumbs}"><a iam-link href="/articles/css">CSS</a></li>
		<li iam-plain-list-item="{--breadcrumbs}"><a iam-link href="/articles/css/iamcss">iAMCss</a></li>
		<li iam-plain-list-item="{--breadcrumbs}">3.0</li>
	</ul>
	<ul iam-plain-list iam-links-list="{--main}">
		<li iam-plain-list-item><a iam-link="{--main}" href="/articles">Статьи</a></li>
		<li iam-plain-list-item><a iam-link="{--main}" href="/social">Контакты</a></li>
		<li iam-plain-list-item><a iam-link="{--main}" href="/price">Цены</a></li>
	</ul>
</div>
```
```css
/* <iam-plain-list> */
[iam-plain-list] {
	margin: 0;
	padding: 0;
}

[iam-plain-list-item] {
	display: inline-block;
}
/* </iam-plain-list> */

/* <iam-plain-list-item--breadcrumbs> */
[iam-plain-list-item *= "{--breadcrumbs}"]:after {
	content: ">";
	margin: 0;
	padding: 0 0 0 1ex;
}

[iam-plain-list-item *= "{--breadcrumbs}"]:last-child:after {
	display: none;
}
/* </iam-plain-list-item--breadcrumbs> */

/* <iam-links> */
[iam-links-list] {
	display: block;
	padding: 1ex 1em;
}
/* </iam-links> */

/* <iam-links--main> */
[iam-links-list *= "{--main}"] {
	padding-left: 0;
}

[iam-link *= "{--main}"] {
	border-right: solid 1px white;
	padding: 0 1em;
}
/* </iam-links--main> */
```

### Родительские/контекстные модификаторы
3.0 позволяет уменьшить [специфичность](https://developer.mozilla.org/ru/docs/Web/CSS/Specificity) от иерархичности селекторов, размещая контекст в рамках скобок "[]", а не через пробел.

## Компонентный подход (vue- web- и прочие)
Компонентный подход подразумевает, что все элементы блока доступны только внутри компонента, но не в общей вёрстке. При компонентном подходе не получится миксовать компоненты, но миксы на некомпонентых элементах по прежнему будут доступны.

Если используются компоненты, то наименование блока становится html-элементом, а все его модификаторы передаются как отдельные атрибуты, с последующим рендерингом в обычную вёрстку по iamCSS.