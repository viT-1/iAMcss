# iam-css styleguide

## Вступление
iam-css не является самостоятельной методологией, это всего лишь нотация,
набор соглашений, призванных облегчить написание и сопровождение css-правил.
Соответственно никакого js-движка, использования утилит по сборке не требуется,
никаких требований по организации структуры папок и файлов iam-css не предъявляет.

iam-css лишь упорядочивает вашу работу по написанию  и использованию css-селекторов,
соответственно вы можете применять эту нотацию в любых фреймворках, вёрстку
которых Вам удобно будет поправить.

## Какую проблему решает iam-css
Как и БЭМ, iam-css помогает проще сопровождать CSS селекторы.
Да, именно сопровождать, поскольку CSS hell/[specificity escalation](https://sadness.dance/) - это ситуация, когда ты
вынужден писать многословные селекторы, или применять !important,
только ради того, чтобы перебить [специфичность каскадируемых селекторов](https://www.w3.org/TR/CSS2/cascade.html#specificity).
Почему вынужден? Потому что порой нет доступа или времени на то, чтобы откорректировать внешний контекст, чтобы он не влиял
на решение текущей задачи.

## Каким образом iam-css решает CSS hell
Классический БЭМ предлагает как использование многословных селекторов (на каждый модификатор)
[в один класс](https://ru.bem.info/methodology/css/#%D0%BA%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5-%D1%81%D0%B5%D0%BB%D0%B5%D0%BA%D1%82%D0%BE%D1%80%D1%8B), но есть и более гибкий, но более css-специфичный
способ в виде [ABEM](https://css-tricks.com/abem-useful-adaptation-bem/).
iam-css, решает задачу указания контекста dom-ноды по-разному: как схожим с классическим БЭМ, схожим с ABEM и более гибко.

Поскольку принято следовать принципу [модульности](https://ailev.livejournal.com/1294242.html)
и меньшей связности, каждый селектор должен определять стили только в рамках самого модуля (блока),
а не его подмодулей (дочерних блоков). Это очень важное ограничение, избавляющее вас от Ада CSS!

Из этой рекомендации следует **первое ограничение**: не использовать в качестве селектора указание на html-тэг.
То есть запрещаются контекстные конструкции свободной вложенности, как то `.theme-dark .text-editor p`.
Но также не рекомендуются контекстные конструкции, строго закладывающие уровень вложенности, как например
`.theme-dark .text-editor > .iam-p`.

Как же быть в данном случае, не заставлять же "оператора ЭВМ", при вёрстке статьи, оформлять тэги с классами/атрибутами?
Конечно же нет. С помощью css-переменных можно передать любой [родительский контекст](#родительский-контекст), не увеличивая специфичность
селектора! Смотри [пример со списками](https://codepen.io/viT-1/pen/BaxKLrw).

В целом же динамическая смена тем оформления должна быть реализована не модификаторами в DOM,
а через подсоединённые css-файлы (link rel="alternate stylesheet") и контекст css-переменных.
Различие же мобильного представления от desktop'ного лежит в наличии обработки touch-событий, отсутствии hover,
нежели к ширине экрана. Оформление, зависящее от ширины экрана тоже не относится
к модификаторам view, а относится к media queries.

Относительно БЭМ, iam-css (с версии 3.1) не заморачивает разработчика рассуждениями о разделении на блок и элемент,
хотя и не отрицает их разницу, позволяя укзывать их подряд, без различий в разделителях слов.
Такой подход упрощает дальнейшее сопровождение проекта, не создавая неудобств в переименовании
атрибутов, когда может понадобиться элемент элемента или же вынос модификатора из значения атрибута
в часть имени атрибута.

Нет строгой необходимости соблюдать минимально возможный вес селектора, не пользуясь
такими вспомогательными вещами, например как [checkbox hack](https://css-tricks.com/the-checkbox-hack/),
который позволяет вынести boolean state всем знакомого `.active` в скрытый input.

**Второе ограничение/решение**
Для уменьшения шанса получить незапланированное влияние стилей одного модуля, на стиль другого,
следует указывать контекст-модификатор (например состояния блока) на самом dom-элементе элемента блока.
От этого правила возможно отступить из соображений производительности,
например если контекстное состояние динамически меняется (`:disabled`, `.active`), а дочерних элементов,
чьи стили зависят от этого состояния, очень много.

**Третье ограничение**
Рекомендуется не использовать пробел в селекторах (смотри раздел [Родительский контекст](#родительский-контекст)).

**Четвёртое ограничение**
Объединение первого и третьего ограничения. Не используйте символ `*`.

## iam-css = БЭМ + AMCSS

iam-css следует методологии БЭМ. БЭМ оперирует тремя основными понятиями:
Блок, Элемент, Модификатор. С модификатором всё понятно, по БЭМу он
[определяется](https://ru.bem.info/methodology/quick-start/#%D0%BC%D0%BE%D0%B4%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82%D0%BE%D1%80) так:
модификатор - сущность, определяющая внешний вид, состояние или поведение блока
либо элемента.
### Элементы элементов
С разделением понятий Блок и Элемент всё гораздо сложнее. Очень часто начинающие БЭМеры
совершают [много ошибок](https://habrahabr.ru/post/305548/), и это нормальное положение
дел, так как верстальщики и js-программисты при работе с HTML-разметкой привыкли
оперировать понятием DOM-элемент (тэг). Можно воспользоваться понятием Абсолютно Независимого Блока
(подобное положение дел высказывалось [на хабре](https://habrahabr.ru/post/203994/)),
либо, с учётом нынешних реалий, проще воспринять разницу следующим образом:
При вёрстке шаблонов компонент (Angular/React/Vue/Web-components), все html-тэги
содержащиеся в вёрстке шаблона компонента - это элементы компонента/блока,
соответственно именование блока устанавливается на корневой html-элемент шаблона,
например [iam-select](https://vit-1.github.io/iAMcss-samples/v3/iam-select/).

Чтобы уйти от этой путаницы, которую архитекторы БЭМа
[заложили в основании БЭМа](https://ru.bem.info/methodology/quick-start/#Когда-создавать-блок-когда-элемент),
iam-css v3 предлагает указывать блок и элемент всплошную вместе, разделяя только слова `block-name-elem-name`,
при необходимости доращивая "хвост" (при этом не придётся переформатировать разделители слов "тела").

### Что нам даёт использование атрибутов вместо значений class?
Ставку делаем на [селекторы атрибутов CSS 2.1](http://caniuse.com/#feat=css-sel2)!
(в своё время БЭМеры [отказались](https://ru.bem.info/forum/-68/) от этой затеи)

Все модификаторы рассматриваются в контексте конкретного блок-элемента (именования атрибута),
что уменьшает путаницу с глобальными модификаторами, которые были в общей свалке до БЭМ,
и уменьшает многословность БЭМа (разработчики Яндекса вынуждены были каждый модификатор
предварять текстом "блок-элемент").

Гугл, кстати, решил уйти от блоков, и [опирается на элементы](https://habrahabr.ru/company/dataart/blog/270109/),
что, без предварительной сборки препроцессорами, возвращает нас к проблемам которые
был призван решить БЭМ: например css-каскадирование, использующееся для того чтобы
отличить один элемент от такого же элемента, но имеющего другой уровень вложенности.

По прошествию времени, и я сделал вывод, что "блок" это [лишь контекстный модификатор](2.2/README.md).
В том числе и более верхний "блок" является лишь модификатором для внешнего вида "элемента".
В отличии от oldstyle, где всё размещалось в атрибуте class, custom-атрибуты позволили
помодульно разделить модификаторы (каждому блоку или блок__элементу своя группировка).

Варианты:
- iam-css 1.0: `.block[element *= "-mod-"]`,
- inverted iam-css 1.1: `.element[block *= "-mod-"]`,
- iam-css 2.0: `*[block__element *= "-mod-"]`,
- iam-css 2.2: `*[element *= "^block^"][element *= "-mod-"]`,
- iam-css 3.2: `[block-element ~= "mod"]`

НО! Если элемент рассматривать как равноправную часть сразу в десятке миксов/блоков (указанных в значении атрибута),
это усложнит код и его восприятие.
Потому в iam-css 3.2 не рекомендуется использовать именование блока в качестве модификатора,
и если необходимо передать контекст iam-root-block, то передавать его через взведённую css-переменную,
а не через значение атрибута.

## Interface
Interface - абстрактное понятие [как в классическом ООП](https://habrahabr.ru/post/30444/),
определяющее набор свойств/функций объекта, но не его реализацию. Не путать с визуальным интерфейсом!

В БЭМе аналогия Interface это "[Блок](https://ru.bem.info/methodology/quick-start/#Блок)".
По сути БЭМу "[Блок](https://ru.bem.info/methodology/quick-start/#Блок)" необходим с той же целью,
с какой используется понятие interface в ООП: для того чтобы отделить одну функциональность от другой
и сгруппировать воедино все составляющие части этой функциональности.

Interface можно рассматривать как prefix/namespace для "Элемента", как группирующая метка имён элементов
подчиняющихся одной функциональности. Например классом iDropDownList по iam-css 1.0 помечены и кнопка
инициирующая отображение полного списка вариантов выбора, и общий контейнер содержащий эту кнопку,
и текстовое поле с выбором.

В нотации iam-css 1.0 интерфейс обязательно должен быть прописан как iClass в html-атрибуте "class"
каждого DOM-элемента вместе составляющих единое целое (отвечающих за одну функциональность).
Не должно быть селекторов типа `.iClass {}`, поскольку интерфейс это объединяющее абстрактное понятие,
а не реальное, принадлежащее конкретной DOM-ноде!

В нотациях iam-css 2.0 и v3 именование блока размещено в виде префикса как часть именования атрибута (элемента).

К чему же тогда должны быть привязаны CSS-селекторы? Если продолжать аналогию с ООП,
то реализацией/классом по iam-css является конкретная DOM-нода, она же "элемент" (по БЭМ),
соответственно селекторы должны основываться на атрибутах размещённых на DOM-элементах.

## Attribute
Attribute - основа реализации селекторов по iam-css как преемника [AMCSS](https://amcss.github.io/).
Атрибут в iam-css 1.0 аналогичен понятию "[Элемент](https://ru.bem.info/methodology/quick-start/#Элемент)" в БЭМ
или (по iam-css с версии 3.1), аналогичен понятию Блок-Элемент (версия 2 поддерживает обе декларации).
HTML-атрибут используется в iam-css для ссылки на конкретный DOM-элемент с которым предстоит работать
(опеределять js-поведение и оформление).

Почему не пользуемся для этих целей атрибутом "class" пояснено в следующем параграфе. Помимо этого
атрибуты позволяют разложить все модификаторы по своим полочкам, что особенно актуально в случае миксов
и при сложных наборах состояний элемента.

Такова эволюция CSS-селекторов HTML-разметки:
- до CSS ([html3](http://citforum.ru/internet/html3.2ex/all.shtml)) оформление размещали в множестве
атрибутов (align, bgcolor, width...)
- затем из атрибутов оформление вынесли в inline-стили
- затем вынесли оформление в отдельный файл, css-селекторы которого основывались на атрибуте "class"
и на именовании тэгов
- после того как атрибут класс был облюбован множеством фреймворков, js-хуков и метками микроданных,
разработчикам, во избежание коллизий, пришлось уводить селекторы в custom data-attributes
- в идеале нас ждёт переход на [веб-компоненты](http://stackoverflow.com/questions/9845011/are-custom-elements-valid-html5#answer-9845124),
Google уже [перешёл](https://material.angularjs.org/latest/CSS/button)!

Если (для валидности) используются data-атрибуты, то рекомендуется префиксом добавлять namespace,
отличающий например вашу `[data-my-button]` от любых других opensource проектов `[data-ms-button]`.

iam-css при работе со стандартными атрибутами (в т. ч. ARIA) не требует фанатичного соблюдения
правила, что в значениях атрибута обязательно должно размещаться значение.
```css
/* iam-css 1.0 */
.iTree[role = "treeitem"] {} /* с использованием aria */
.iTree[data-am-item] {} /* без использования aria, свой valid HTML "велосипед" */

/* iam-css 1.1 */
.leaf[x-mas-tree] {}

/* iam-css 2.0 */
*[data-iam-tree__item] {}
*[iam-tree--item] {} /* это не модификатор, просто кто-то любит только дефисы */

/* iam-css 2.2 */
*[x-item *= "^x-tree^"] {}

/* iam-css 3.1.1 */
[iam-tree-item *= "iam-south-park v-pine"] {}
[iam-south-park-tree-item ~= "v-pine"] {}
```

Идеологически блок/интерфейс не может иметь модификатор, тогда как контейнер блока (соответствующий элемент) может.
Практически же, с версии v3, корневой элемент всегда именуется один в один с названием блока.
Корневой элемент/контейнер, в котором располагаются все элементы "блока" может также называться holder'ом,
либо, если этот контейнер объединяет множество однородных элементов, может называться list или items.
Например:
```css
/* iam-css 1.0, когда сам блок не имеет модификатора, а контейнер имеет */
.iTree[data-am-list *= "-small-"] {} /* без использования aria, свой "велосипед" с valid аттрибутами */

/* iam-css 1.1, модификаторы указываются при имени блока - удобно функциональность миксов, при одном и том же элементе, разделать */
.holder[x-mas-tree *= -small-] {} /* инвертированный вариант. Без оглядки на валидность атрибута */

/* iam-css 2.0 */
*[x-tree__holder *= "-small-"] {}

/* iam-css 2.2 с блочно-контекстным модификатором */
*[x-holder *= "^x-tree^-small-"] {}

/* iam-css v3 valid attr */
[data-iam-tree ~= small] { /* установка space toggler для small в корневом элементе */ }
[data-iam-tree-leaf] { /* проверка родительского space toggler в дочернем элементе  */ }
```

## Modificator
Modificator - Cущность, доопределяющая внешний вид (view) или состояние элемента (state `is-`). Состояния являются
одним из видов модификаторов и описаны подробнее ниже. Значения модификаторов размещаются в html-атрибутах
(смотри [валидность custom-атрибутов](https://github.com/whatwg/html/issues/2271) по W3C).
В сравнении с БЭМ'ом, для простоты восприятия, в определении исключено упоминание о "Блоке".

Имя модификатора размещается в значении атрибута, и тем самым iam-css решает ту же
проблему, что и [CSS-modules](https://github.com/css-modules/css-modules): даёт возможность иметь базу
(селектор атрибута) и доопределять элемент модификатором при помощи селектора атрибута с его значением,
например `*[x-tree__leaf *= "-small-"]`
при том же весе специфичности селектора, не создавая для этого дополнительный класс (как это делает БЭМ).

Для тонкой настройки конкретного экземпляра реиспользуемого блока, вместо того чтобы использовать
селектор #myId, чтобы вес селектора остался минимальным, рекомендуется воспользоваться атрибутивным селектором,
например:
```css
*[x-tree__list *= "-iconed-"]{}
*[id = "folders"]{ /* отличать -iconed- с помощью контекстной переменной */ }
```

В модификаторе, ради минимизации веса селектора, возможно комбинировать жёстко зафиксированные
по порядку значения, например:

```css
/* iam-css 2.0 */
*[iam-combobox__item *= -vSpcMinimal-]{
	margin: 0;
	padding: 0;
	line-height: 1.2em;
}

*[iam-combobox__item *= -wgtCounries--vSpcMinimal-]{
	width: 200px;
}

/* iam-css 3.0 */
[iam-combobox-item *= "{iam-countries}{--spc-minimal}"]{
	width: 200px;
}

/* iam-css 3.1.1 */
[iam-combobox-item *= "iam-countries spc-minimal"]{
	width: 200px;
}
```

В iam-css v3.2 модификатор родительского контекста, отличается от модификаторов-состояний тем,
что динамически не меняется. Предназначен для того чтобы не привязываться к порядку модификаторов,
контекст возможно вынести в переменную ([флаг контекста](https://github.com/propjockey/css-sweeper#basics-of-space-toggle)), например:
```css
[iam-list] {
	--iam-list--: ; /* toggler родительского контекста */
}

[id = "countries"] {
	--iam-list-countries--: var(--iam-list--); /* toggler примиксованного контекста к другому родительскому */
}

[iam-list ~= "countries"] { /* или модификатором в iam-list */
	--iam-list-countries--: var(--iam-list--);
}

[iam-list ~= "spc-minimal"] {
	--iam-list-spc-minimal--: ;
}

/* рекомендуется использовать всё же не тэг, а предустановленный атрибут, например iam-li */
li {
	--iam-list-font-size-base: var(--iam-list--) 15px;
	--iam-list-countries-font-size: var(--iam-list-countries--) 20px;
	font-size: var(--iam-list-countries-font-size, var(--iam-list-font-size-base, 18px));

	--iam-list-li-line-height-base: var(--iam-list--) 1.6;
	--iam-list-li-line-height-min: var(--iam-list-spc-minimal--) .8;
	line-height: var(--iam-list-li-line-height-min, var(--iam-list-li-line-height-base));

	--iam-list-li-color: var(--iam-list--) orange;
	color: var(--iam-list-li-color, inherit);
}
```

iam-css перед реализацией БЭМа, использующей атрибут class, имеет синтаксическое преимущество:
отсутствие дублирующей громоздкого сочетания блок-элемент предваряющего значение модификатора.
К тому же, в случае миксов, разметка HTML по БЭМу превращается в свалку длинных наименований классов,
тогда как iam-css позволяет все модификаторы сгруппировать по своим атрибутам.

Для декларации модификатора, которым следует пользоваться всем элементам микса, возможно использование
атрибута "class" - это будет "общак" ;) Не забывайте, что "class" скорей всего используется и другими
фреймворками, потому добавляйте к наименованию модификатора namespace (префикс проекта/организации).

## Состояние
Состояние - динамически изменяющийся модификатор, отвечающий за отображение элемента и в целом блока
(состояние блока задаёт контекст отображения элементов блока).
Элемент/контейнер блока может находится сразу в нескольких состояниях.

Состояния, в отличии от модификаторов, могут иметь одни и те же названия в разных блоках (например миксах) и элементах.

Использование стандартного способа указания состояния при помощи стандартных
атрибутов или [WAI ARIA](https://www.w3.org/WAI/ARIA/project) ([мнение Pepelsbey](https://web-standards.ru/podcast/328/#00:39:24)), таких как disabled, checked, hidden, readonly,
required, aria-busy, aria-expanded, aria-grabbed, aria-invalid, aria-pressed, aria-readonly, aria-required,
aria-selected, приводит к усложнению и увеличению веса селектора.
Дублировать disabled и checked в aria-disabled и aria-checked нет смысла.

Предпочтительней не ориентировать визуальное состояние на ARIA-атрибуты, и размещать наименования состояний
в атрибут Элемента (block-elem) в качестве значений, возможно группировать view и state
- 1.0 и 2.0: `-viewName--stateName-`,
- 3.0: `{v-name}{s-name}`
- 3.1.1 `v-name s-name`
- 3.2.1 `some-view-name is-named-state`, с разделением слов через символ `-`

Селекторы состояний могут выглядеть следующим образом
(tooltip реализован как подкомпонент компонента tree):
```css
/* iam-css 1.0 */
.iTree[role = "treeitem"][aria-expanded = "true"] {}
.iTreeTooltip[x-hoverlabel]:hover {}
.iTreeTooltip[x-hoverlabel *= "-loading-"] {}

/* iam-css 1.1 "inverted" */
.leaf[x-mas-tree][aria-expanded = "true"] {}
.hoverlabel[x-mas-tree-tooltip]:hover {}
.hoverlabel[x-mas-tree-tooltip *= -loading-] {}

/* iam-css 2.0 */
*[data-my-tree__item][aria-expanded = "true"] {}
*[data-my-tree-tooltip__hoverlabel]:hover {}
*[data-my-tree-tooltip__hoverlabel *= -loading-] {}

/* iam-css 2.2 */
*[x-item *= "^my-tree^"][aria-expanded = "true"]{}
*[x-hoverlabel *= "^my-tree-tooltip^"]:hover {}
*[x-hoverlabel *= "^my-tree-tooltip^"][x-hoverlabel *= "-loading-"] {}
*[x-hoverlabel *= "^my-tree-tooltip^-loading-"] {} /* states идут строго за родительским контекстом блока */

/* iam-css 3.2 */
[aria-expanded = true] { --is-aria-expanded: ; }
[iam-tree-item] { /* использование флага var(--is-aria-expanded) */ }

[iam-tree-tooltip-hoverlabel]:hover {}
[iam-tree-tooltip-hoverlabel ~= loading]
```

Необходимо понимать, что составные селекторы наращивают специфичность, старайтесь придерживаться
минимальной специфичности (либо какой-то базовой), чтобы при написании переопределяемого селектора
не приходилось искуственно наращивать специфичность. v3.2 наименее специфичен.

### Состояние по умолчанию / undefined
Даже в случае если у вас элемент имеет всего два состояния, рекомендуется прописывать оба,
а не определять оформление элемента по умолчанию + переопределять эти же свойства в контексте
одного из состояний. В качестве исключения можно назвать состояния с использованием стандартизированных
атрибутов `:disabled` и `:checked`, управление которыми заключается в их добавлении/удалении.
При наличии модификатора базового состояния, его toggle к новому состоянию возможно будет закрепить
в предсказуемом месте среди множества значений атрибута.
В противном случае модификаторы будут как на конвейере перепрописываться в конец атрибута.
Разумеется любую рекомендацию вы можете игнорировать ;)

## Динамические нативно поддерживаемые состояния
Если для управления состоянием блок-элемента не используется js,
то в iam-css не считается зазорным использовать например `:hover, :disable, :focus`.

## Вариация отображения (view)
Используется для внесения незначительных модификаций отображения, позволяет обойтись без миксов.
Сюда же можно отнести и незначительные правки уникально-идентифицируемых элементов посредством `[id = "countries"]`
или `[iam-menu = "top"] {} [iam-menu = "bottom"] {}`. Для корректировки отображения в v3.2 данные селекторы
следует рассматривать как [контекстные](#родительский-контекст).

## Неявно указанные view (цветовые темы и адаптивность)
В общей концепции iam-css прописано, что view - это тип модификатора, который отвечает
за вариант визуального представления блок-элемента. Но не всегда view указывается явно
в качестве значения атрибута на блок-элементе.

Такие view можно определить исходя из UX (полезное на [weblind.ru](https://weblind.ru/)):
- цветовой оттенок ([night/day skins](https://github.com/pepelsbey/playground/tree/main/scheme-switcher), [почему](https://web.dev/prefers-color-scheme/), [WCAG рекомендации](https://www.w3.org/WAI/WCAG21/quickref/?showtechniques=141#use-of-color)).
- цветовой контраст ([WCAG рекомендации](https://www.w3.org/WAI/WCAG21/quickref/?showtechniques=141%2C146#contrast-enhanced), [мифы о контрасте](https://uxmovement.com/buttons/the-myths-of-color-contrast-accessibility/))
- размеры элементов и текста ([WCAG рекомендации](https://www.w3.org/WAI/WCAG21/quickref/?showtechniques=141%2C146%2C144#resize-text), [обсуждение(https://gist.github.com/aaugustin/d6351f12f4604d3343ee5ecf691b3918)]) [Пример](https://vit-1.github.io/hobby/)
- развитие [mobile first](https://css-tricks.com/how-to-develop-and-test-a-mobile-first-design-in-2021/) - [опора на возможности](https://mattanddesign.com/dont-design-for-mobile/) (более легковесные ресурсы, экономящие веб-траффик, click/touch элементы, [ошибка называть](https://habr.com/ru/post/451518/) mobile версию "урезанной")
- адаптация к ширине браузера (перенос, видоизменение или сокрытие элементов). [Пример](https://github.com/viT-1/larinayoga/blob/3a217d9d798ec1cc22be307538c50371f053130a/xsl/conf.xml#L30-L33)
- адаптация для печати (сокрытие ненужных элементов и экономия чернил) [Пример](https://github.com/viT-1/larinayoga/blob/3a217d9d798ec1cc22be307538c50371f053130a/xsl/conf.xml#L35)

Вышеобозначенные views, отсутствующие в спике модификаторов блок-элемента, могут изменяться средствами js
(через установку пользовательских настроек), либо средствами html (например ширина окна браузера).

Изменение варианта таких view возможно как заменой `url` тэга `<link>`, так и через явную установку
флагов в качестве значений атрибута `data-themes` или соответствующих классов на одном из корневых элементов страницы.
Указываем значения одних и тех же css-переменных в контекстах одного типа,
например `[data-themes ~= "night"] {}` и `[data-themes ~= "day"] {}` и используем эти
переменные в селекторах блок-элементов.

Но использование `data-themes` не будет соответствовать стратегии mobile first, так как необходимо
будет подключить все файлы стилей, а это траффик.

Рассмотрим файлы-шкурки/темы (skins).
Если раньше мы писали что-то типа `.dark .myNumberInputLabel`,
то теперь, используя возможности [css-variables](https://medium.com/front-end-weekly/theming-with-css-variables-e4f30343c7c7)
(для ie11 [polyfill](https://github.com/nuxodin/ie11CustomProperties), [тест](https://jsbin.com/dapunoquyo/1/)) пишем:
```css
.sknLight { --t-primary-color: black; } /* Тема по умолчанию */ 
.sknDark { --t-primary-color: white; }

/* iam-css 1.0 */
.my-iInput[type = "number"] { color: var(--t-primary-color); }

/* iam-css 2.0 */
*[data-my-input][type = "number"] { color: var(--t-primary-color); }

/* iam-css 3.1.1 */
*[iam-input][type = number] { color: var(--t-primary-color); }
```

## Специфичность модификаторов доопределяющих модуль (custom styling)
Даже современные готовые решения, например такое как [vuetify](https://github.com/vuetifyjs/vuetify/blob/0f980ad51e22ba82e46f750eadcb7a586c802553/packages/vuetify/src/components/VChip/VChip.sass#L188) грешат
селекторами, у которых специфичность сверх меры повышена при отсутствии
возможности указать css-переменную соответствующего правила, например
для состояния active. Переопределять такие селекторы повышая специфичность ещё сильнее, накручивая к тому же important - тупиковый путь, потому следует к тем правилам миксовать простейший БЭМ или iam-css, [например так](https://github.com/viT-1/iAMcss-samples/commit/4bcecb8d9f85b9bd9c80e4d5725ca96d2cc2ddfa).

## Миксы
[Миксы](https://ru.bem.info/methodology/quick-start/#Микс) возможно реализовать только при помощи
html-атрибутов (или их значений), поскольку каждый DOM-элемент обязан иметь одно конкретное имя
html-тэга, а не множество, тогда как на одном тэге можно разместить большое количество всевозможных
атрибутов, благодаря чему и реализовать микс.

С точки зрения iam-css, миксы являются аналогом множественного наследования интерфейсов в ООП.
Реализация миксов по iam-css 1.0 и 2.0 несколько различается: в первом случае это набор iКлассов
в атрибуте "class", во втором случае это набор атрибутов на одной html-ноде.

Поскольку миксы рассматриваются как множественное наследование перечислением интерфейсов, то в идеале,
во избежание коллизий и работы со специфичностью селекторов, селекторы `.iClassA[holder] и iClassB[holder]`
(или `*[class-a__holder]` и `*[class-b__holder]`) не должны определять
одинаковые css-свойства, либо эти блоки не должны быть замиксованы вместе на одной DOM-ноде.

Если возможно, лучше обойтись значением модификатора, добавленным к имеющимся.
Микс, начиная с iam-css v2 это возможность сгруппировать в новом атрибуте дополнительный набор модификаторов,
потому использовать его нужно, только если необходимо реализовать именно такой богатый функционал.

ВАЖНО!
В БЭМе миксы используют для того чтобы отделить общие layout-правила (отвечающие за различные размеры и отступы элементов
внутри контейнера) от оформления контейнера которое зависит от того в каком родительском блоке/элементе он находится.
Смотри уже устаревшие [holder/layout блоки](http://vitaly.harisov.name/article/independent-blocks.html),
которые претерпели множество изменений в рамках методологии БЭМ, и [Родительский контекст](#родительский-контекст).

Пример примиксовывания общей/глобальной стилистики заголовков в виде блока `iam-h` к элементу `iam-popup-title`:
```html
<dl iam-popup id="countries">
	<dt iam-h="sknDark h3" iam-popup-title="spc-normal">Popup title</dt>
	<dd iam-popup-content>Some content</dd>
</dl>
```

## Валидность префиксов
Если вы любитель [кнопок-бэйджиков от W3C](https://www.w3.org/QA/Tools/Icons), то наверное знаете,
что стандартом HTML5 допускаются помимо WAI-ARIA и стандартных атрибутов только
[data- атрибуты](https://www.w3.org/TR/2014/REC-html5-20141028/dom.html#attr-data-*),
остальные атрибуты считаются инвалидными ;)

Если использовать XHTML или XML, то у вас не будет этого ограничения, и вы не обязаны будете каждый
свой атрибут (да ещё и с префиксом) предварять префиксом data-. Как вариант, можно вообще
игнорировать тот факт, что код у вас не совсем валидный, и для удобочитаемости [опускать
префиксы data-](https://habrahabr.ru/post/139210/#comment_4652461). Только необходимо помнить о том,
что вы работаете в глобальном пространстве имён, и, чтобы случайно не пересечься с каким-либо сторонним
фреймворком, его необходимо сужать введением своих префиксов (например проекта/организации).

Если же так важна валидность используйте автоматизирующие вашу работу инструменты.
Можно и не возвеличивать валидность, в качестве префиксов атрибутов использовать свои наименования.

## JS-хуки.
Для упрощения сопровождения css-селекторов, вместо `getElementById` вызывайте `querySelector('[id = "countries"]')`,
с заранее известной DOM-ноды (не с корня html), чтобы сузить область срабатывания селектора.
Соответственно в файлах css для атрибутивных селекторов не пренебрегайте кавычками, так проще потом будет искать.

Параметр для `querySelector` или `querySelectorAll` не должен быть
динамически собираемым, чтобы необходимое js-влияние по селектору легко было обнаружено верстальщиком.
Верстальщик при изменении селекторов в CSS-файлах обязан также проверять и JS код на наличие CSS-подобных
селекторов в querySelectorAll, потому для JS не требуется заводить дублирующий data-атрибут,
который в других методологиях призван отделить работу js от представления.
Сам же JS-код не должен менять стили программно, он обязан только управлять сменой
[состояний](#Состояние) элемента/блока.

## Родительский контекст
Вложенные (пробельные) селекторы типа `.class1 .class2` [это плохой код](https://ru.bem.info/methodology/css/#%D0%B2%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D1%81%D0%B5%D0%BB%D0%B5%D0%BA%D1%82%D0%BE%D1%80%D1%8B),
из-за повышения специфичности, да и потому, что вам самим неудобно работать с селекторами
сторонних фреймворков, которые переопределяют оформление вашего элемента. Но если вам
уж сильно не хочется на каждый li и td вешать атрибуты/классы вашего элемента/блока, то
воспользуйтесь современным способом "[space toggle](https://github.com/propjockey/css-sweeper#basics-of-space-toggle)"
в случае со списком вместо `[iam-list] li` предпочтите решение:
```css
:root {
	--list-item-clr: orange;
}

[iam-list] {
	--iam-list--: ; /* родительский контекст/переключатель */
}

/* Модификаторов у одного и того же списка может быть множество */
[iam-list ~= unordered] {
	--iam-list-unordered--: ;
}

li {
	--iam-list-item-clr: var(--iam-list--) plum;
	color: var(--iam-list-item-clr, var(--list-item-clr), inherit);
}
```

Если в таблице стилей указывать селекторы жёстко по вложенности, то рано или поздно
[они сломаются](https://habrahabr.ru/post/270075/#comment_8641367) - из-за появления промежуточных dom-элементов.

Если мы хотим использовать стандартные контролы и не прописывать всё поведение с нуля
(например свои чекбоксы с состояниями disabled, checked), то никуда не деться от повышения
специфичности селектора. Написание кода по iam-css не должно противоречить современным техникам,
например таким как [css3 checkbox/radio hack](Если мы хотим использовать стандартные контролы и не прописывать всё поведение с нуля
(например свои чекбоксы с состояниями disabled)).

## Актуальная, версия 3.2
[Краткая документация](https://github.com/viT-1/iAMcss/blob/master/v3/styleguide.md) по iam-css v3

## Примеры кода
- Разные примеры, по iam-css [3.1 и 3.2](https://vit-1.github.io/iAMcss-samples/), в том числе обновлённые из нижеперечисленных.
- Тулбар с применением checkbox-hack в соседстве с ARIA-атрибутами, сложные селекторы [по iam-css 2.0](https://codepen.io/viT-1/pen/KXyyGM) (2017.10.09)
- Микс кнопки и выпадающего списка, не столь актуальный с учётом предыдущих два примера, зато [по iam-css 1.0](http://codepen.io/viT-1/pen/VjXybd) (2016.12.08)
- [Font Awesome чекбоксы/радио-кнопки](https://vit-1.github.io/iAMcss-samples/v3/styled-checkbox-radio/) с применением iam-css [2.0](http://codepen.io/viT-1/pen/GrBwbE)
- Виджет vp-tree__list JSON [по iam-css 2.0](https://codepen.io/viT-1/pen/XVxEgX) и <del title="ico sources broken">SVG-иконками</del> разных размеров (2018.01.18)