# iAMcss styleguide

## Вступление
iAMcss не является самостоятельной методологией, это всего лишь нотация,
набор соглашений, призванных облегчить написание и сопровождение css-правил.
Соответственно никакого js-движка, использования утилит по сборке не требуется,
никаких требований по организации структуры папок и файлов iAMcss не предъявляет.

iAMcss лишь упорядочивает вашу работу по написанию  и использованию css-селекторов,
соответственно вы можете применять эту нотацию в любых фреймворках, вёрстку
которых Вам удобно будет поправить.

## Какую проблему решает iAMcss
Как и БЭМ, iAMcss помогает проще сопровождать CSS селекторы.
Да, именно сопровождать, поскольку CSS hell/[specificity escalation](https://sadness.dance/) - это ситуация, когда ты
вынужден писать многословные селекторы, или применять !important,
только ради того, чтобы перебить [специфичность каскадируемых селекторов](https://www.w3.org/TR/CSS2/cascade.html#specificity).
Почему вынужден? Потому что порой нет доступа или времени на то, чтобы откорректировать внешний контекст, чтобы он не влиял
на решение текущей задачи.

Помимо этого, следуя принципу [модульности](https://ailev.livejournal.com/1294242.html) и меньшей связности, каждый селектор должен определять стили только в рамках самого модуля (блока), а не его подмодулей (дочерних блоков).
Из чего можно сделать первую рекомендацию: не использовать в качестве селектора указание на html-тэг.
То есть запрещаются контекстные конструкции свободной вложенности, как то `.theme-dark .text-editor p`.
Но и не рекомендуются контекстные конструкции, строго закладывающие уровень вложенности, как например
`.theme-dark .text-editor > p`.

Как же быть в данном случае, не заставлять же "оператора ЭВМ" оформлять тэги с классами/атрибутами?
Конечно же нет. Можно провести xslt-трансформацию, где каждому элементу будет указан
класс/атрибут указывающий на контекст "text-editor" и на цветовую схему "dark".
Например:
1.0 `*[iam-owns *= "-text-editor-"][iam-view *= "-dark-"]`,
2.0 `*[text-editor *= "-dark-"]`,
3.1 в dark.css прописать `[text-editor-p]`

В целом же динамическая смена тем оформления должна быть реализована не модификаторами в DOM,
а через подсоединённые css-файлы (link rel="alternate stylesheet") и контекст css-переменных.
Различие же мобильного представления от desktop лежит в наличии обработки touch-событий, отсутствии hover,
нежели к ширине экрана. Оформление, зависящее от ширины экрана тоже не относится
к модификаторам view, а относится к media queries.

Нет строгой необходимости соблюдать минимально возможный вес селектора, не пользуясь
такими вспомогательными вещами, как в случае с [checkbox hack](https://css-tricks.com/the-checkbox-hack/),
который позволяет вынести boolean state всем знакомого `.active` в скрытый input.
Но есть необходимость ограничивать влияние селекторов только рамками самого модуля, а именно
в пределах конкретного dom-элемента. То есть весь необходимый контекст по возможности рекомендуется указывать
на самом dom-элементе. От этого правила возможно отступить из соображений производительности,
например если контекстное состояние динамически меняется (`:disabled`, `.active`), а дочерних элементов,
чьи стили зависят от этого состояния, очень много.

## iAMcss = БЭМ + AMCSS

iAMcss следует методологии БЭМ. БЭМ оперирует тремя основными понятиями:
Блок, Элемент, Модификатор. С модификатором всё понятно, по БЭМу он
[определяется](https://ru.bem.info/methodology/quick-start/#Модификатор) так:
модификатор - сущность, определяющая внешний вид, состояние или поведение блока
либо элемента.
### Элементы элементов
С разделением понятий Блок и Элемент всё гораздо сложнее. Очень часто начинающие БЭМеры
совершают [много ошибок](https://habrahabr.ru/post/305548/), и это нормальное положение
дел, так как верстальщики и js-программисты при работе с HTML-разметкой привыкли
оперировать понятием DOM-элемент (тэг). Можно воспользоваться понятием Абсолютно Независимого Блока
(подобное положение дел высказывалось [на хабре](https://habrahabr.ru/post/203994/)),
либо, с учётом нынешних реалий, проще воспринять разницу следующим образом:
При вёрстке шаблонов компонент (Angular/React/Vue/Web-components), все нативные html-тэги
в вёрстке - это элементы компонента/блока, а все ненативные (подблоки) это по БЭМу миксы
на одном DOM-элементе, например результирующий рендеринг dom может быть таким:
1.0 `class = "child parent__child"`,
3.1.1 `iam-child = "iam-parent" iam-parent-child`
Поскольку подблок в своей компонентной реализации изменит рендеринг своего dom-элемента,
то передавать в него надо будет только parent (текущий контекст): `<vue-elem :parent="currentBlockName" />`

Чтобы уйти от этой путаницы, которую архитекторы БЭМа
[заложили в основании БЭМа](https://ru.bem.info/methodology/quick-start/#Когда-создавать-блок-когда-элемент),
iAMcss v3 предлагает указывать блок и элемент всплошную вместе, разделяя только слова `block-name-elem-name`,
при необходимости доращивая "хвост" (при этом не придётся переформатировать разделители слов "тела").

### Что нам даёт использование атрибутов вместо значений class?
Ставку делаем на [селекторы атрибутов CSS 2.1](http://caniuse.com/#feat=css-sel2)!
(в своё время БЭМеры [отказались](https://ru.bem.info/forum/-68/#comment-) от этой затеи)

Все модификаторы, в том числе и родительские (гибкое указание контекста без изменения имени атрибута),
рассматриваются в контексте конкретного блок-элемента, что уменьшает путаницу, которая была
в общей свалке до БЭМ, и уменьшает многословность БЭМа (они вынуждены были каждый модификатор
предварять текстом "блок-элемент").

Гугл, кстати, решил уйти от блоков, и [опирается на элементы](https://habrahabr.ru/company/dataart/blog/270109/),
что, без предварительной сборки препроцессорами, возвращает нас к проблемам которые
был призван решить БЭМ: например css-каскадирование, использующееся для того чтобы
отличить один элемент от такого же элемента, но имеющего другой уровень вложенности.

По прошествию времени, и я сделал вывод, что "блок" это [лишь контекстный модификатор](2.2/README.md).
В том числе и более верхний "блок" является лишь модификатором для внешнего вида "элемента".
В отличии от oldstyle, где всё размещалось в атрибуте class, custom-атрибуты позволили
помодульно разделить модификаторы (каждому блоку или блок__элементу своя группировка).
Варианты:
iAMcss 1.0: `.block[element *= "-mod-"]`,
inverted iAMcss 1.1: `.element[block *= "-mod-"]`,
iAMcss 2.0: `*[block__element *= "-mod-"]`,
iAMcss 2.2: `*[element *= "^block^"][element *= "-mod-"]`,
iAMCss 3.1.1: `[block-element ~= mod]` и `[block-element *= "iam-root-block mod"]`

## Interface
Interface - абстрактное понятие [как в классическом ООП](https://habrahabr.ru/post/30444/),
определяющее набор свойств/функций объекта, но не его реализацию. Не путать с визуальным интерфейсом!

В БЭМе аналогия Interface это "[Блок](https://ru.bem.info/methodology/quick-start/#Блок)".
По сути БЭМу "[Блок](https://ru.bem.info/methodology/quick-start/#Блок)" необходим с той же целью,
с какой используется понятие interface в ООП: для того чтобы отделить одну функциональность от другой
и сгруппировать воедино все составляющие части этой функциональности.

Interface можно рассматривать как prefix/namespace для "Элемента", как группирующая метка имён элементов
подчиняющихся одной функциональности. Например классом iDropDownList по iAMcss 1.0 помечены и кнопка
инициирующая отображение полного списка вариантов выбора, и общий контейнер содержащий эту кнопку,
и текстовое поле с выбором.

В нотации iAMcss 1.0 интерфейс обязательно должен быть прописан как iClass в html-атрибуте "class"
каждого DOM-элемента вместе составляющих единое целое (отвечающих за одну функциональность).
Не должно быть селекторов типа `.iClass {}`, поскольку интерфейс это объединяющее абстрактное понятие,
а не реальное, принадлежащее конкретной DOM-ноде!

В нотациях iAMcss 2.0 и v3 именование блока размещено в виде префикса как часть именования атрибута (элемента).

К чему же тогда должны быть привязаны CSS-селекторы? Если продолжать аналогию с ООП,
то реализацией/классом по iAMcss является конкретная DOM-нода, она же "элемент" (по БЭМ),
соответственно селекторы должны основываться на атрибутах размещённых на DOM-элементах.

## Attribute
Attribute - основа реализации селекторов по iAMcss как преемника [AMCSS](https://amcss.github.io/).
Атрибут в iAMcss аналогичен понятию "[Элемент](https://ru.bem.info/methodology/quick-start/#Элемент)" в БЭМ.
HTML-атрибут используется в iAMcss для ссылки на конкретный DOM-элемент с которым предстоит работать
(опеределять js-поведение и оформление).

Почему не пользуемся для этих целей атрибутом "class" пояснено в следующем параграфе. Помимо этого
атрибуты позволяют разложить все модификаторы по своим полочкам, что особенно актуально в случае миксов
и при сложных наборах состояний элемента.

Такова эволюция CSS-селекторов HTML-разметки:
- до CSS ([html3](http://citforum.ru/internet/html3.2ex/all.shtml)) оформление размещали в множестве
атрибутов (align, bgcolor, width...)
- затем из атрибутов оформление вынесли в inline-стили
- затем вынесли оформление в отдельный файл, css-селекторы которого основывались на атрибуте "class"
и на именовании тэгов
- после того как атрибут класс был облюбован множеством фреймворков, js-хуков и метками микроданных,
разработчикам, во избежание коллизий, пришлось уводить селекторы в custom data-attributes
- в идеале нас ждёт переход на [веб-компоненты](http://stackoverflow.com/questions/9845011/are-custom-elements-valid-html5#answer-9845124),
Google уже [перешёл](https://material.angularjs.org/latest/CSS/button)!

iAMcss при работе со стандартными атрибутами (в т. ч. ARIA) не требует фанатичного соблюдения
правила, что в значениях атрибута должно размещаться только его значение-модификатор.
```css
/* iAMcss 1.0 */
.my-iTree[role = "treeitem"] {} /* с использованием aria */
.my-iTree[data-item] {} /* без использования aria, свой valid HTML "велосипед" */

/* iAMcss 1.1 */
.leaf[x-mas-tree] {}

/* iAMcss 2.0 */
*[data-my-i-tree__item] {}
*[iam-tree--item] {} /* это не модификатор, просто кто-то любит только дефисы */

/* iAMcss 2.2 */
*[x-item *= "^my-tree^"] {}

/* iAMcss 3.1.1 */
[iam-tree-item *= "iam-south-park pine"] {}
[iam-south-park-tree-item ~= "pine"] {}
```

## Modificator
Modificator - Cущность, доопределяющая внешний вид (view) или поведение элемента. Состояния являются
одним из видов модификаторов и описаны подробнее ниже.
В сравнении с БЭМ'ом, для простоты восприятия, в определении исключено упоминание о "Блоке".
Блок/интерфейс не может иметь модификатор, тогда как контейнер блока (соответствующий элемент) может.
Корневой контейнер, в котором располагаются все элементы "блока" может называться holder'ом,
либо, если этот контейнер объединяет множество элементов, может называться list или items.
Например:
```css
/* iAMcss 1.0 */
.my-iTree[x-list] {}

/* iAMcss 1.1 */
.leafs[x-mas-tree] {}

/* iAMcss 2.0 */
*[x-tree__list] {}

/* iAMcss 2.2 с блочно-контекстным модификатором */
*[x-list *= "^my-tree^"] {}

/* iAMcss v3 valid attr */
[data-tree-list] {}
```

Имя модификатора размещается в значении атрибута, и тем самым iAMcss решает ту же
проблему, что и [CSS-modules](https://github.com/css-modules/css-modules): даёт возможность иметь базу
(селектор атрибута) и доопределять элемент модификатором при помощи селектора атрибута с его значением,
например `*[x-tree__list *= "-iconed-"]`
не создавая для этого дополнительный класс (как это делает БЭМ).

Для тонкой настройки конкретного экземпляра реиспользуемого блока, вместо того чтобы использовать
селектор #myId, чтобы вес селектора остался минимальным, рекомендуется воспользоваться атрибутивным селектором,
например `*[x-tree__list *= "-iconed-"][id = "folders"]`.

Чтобы использовать CSS3 селекторы без ошибок, рекомендуется именования модефикаторов оборачивать
в начале и конце символом "-" либо "_" (только их разрешается использовать в селекторах без кавычек).
В iAMcss 3.0 приходится в селекторах прописывать кавычки, поскольку в качестве разделителей модификаторов
используются фигурные скобки, так как "-" уже занят для разделения слов, а "_" будет плохо считываться.
iAMcss 3.1.1 решил эту проблему благодаря селектору ~=
В iAMcss 2.2 для указания блока как модификатора, использовать "^" (в v3 именование parent-атрибута как есть).
Разделять модификаторы пробелами нет необходимости. Чтобы не увеличивать вес селектора, можно
комбинировать соседние модификаторы (но требуется гарантировать сохранение порядка модификаторов), например:

```css
/* iAMcss 2.0 */
*[my-combobox__item *= -sknDark-]{
	color: var(--sknDarkClrBaseFrnt);
}

*[my-combobox__item *= -spcMinimal-]{
	margin: 0;
	padding: 0;
	line-height: 1.2em;
}

*[my-combobox__item *= -wgtCounries--spcMinimal-]{
	width: 200px;
}

/* iAMcss 3.1.1 */
[iam-combobox-item *= "iam-counries spc-minimal"]{
	width: 200px;
}
```

iAMcss перед реализацией БЭМа, использующей атрибут class, имеет синтаксическое преимущество:
отсутствие дублирующей громоздкой строки с путём до элемента предваряющей значение модификатора.
К тому же, в случае миксов, разметка HTML по БЭМу превращается в свалку длинных наименований классов,
тогда как по iAMcss все модификаторы сгруппированы по своим атрибутам (при том их возможно будет несколько).

Для декларации модификатора, которым следует пользоваться всем элементам микса, возможно использование
атрибута "class" - это будет "общак" ;) Не забывайте, что "class" скорей всего используется и другими
фреймворками, потому добавляйте к наименованию модификатора namespace (префикс проекта/организации).

Если необходимо изменить отображение элемента в контексте одного из состояний/view родительского элемента (блока),
то, если есть желание не увеличивать количество атрибутов на элементе, селектор 2.0 может выглядеть подобным образом:
`*[my-sidebar__caption *= "^my-sidebar--slave^"]`, инчае мы бы написали так: `*[my-sidebar--slave__caption]`.
При острой необходимости я предпочитаю пользоваться первым вариантом, чтобы модификаторы присутствовали только в
атрибутивных значениях отведённых под модификаторы. Но предпочтение отдаю модификаторам элементов,
т.е. предыдущий пример следует упростить до варианта `*[my-sidebar__caption *= -slave-]`, добавив
соответствующий модификатор в разметку.

## Состояние
Состояние - сущность-признак отвечающая за отображение элемента и в целом блока (состояние блока задаёт
контекст отображения элементов блока), в отличие от модификаторов, динамически изменяется.
Элемент/контейнер блока может находится сразу в нескольких состояниях.

Состояния, в отличии от модификаторов, могут иметь одни и те же названия в разных блоках и элементах,
уникальность селектора гарантируется за счёт указания имени блока и элемента. Конечно можно описывать
состояния не привязываясь к конкретному блоку, но необходимо помнить, что css-свойства в таком селекторе
скорее всего для конкретного блока прийдётся переопределять.

Использование стандартного способа указания состояния при помощи стандартных
атрибутов или [WAI ARIA](https://www.w3.org/WAI/ARIA/project), таких как disabled, checked, hidden, readonly,
required, aria-busy, aria-expanded, aria-grabbed, aria-invalid, aria-pressed, aria-readonly, aria-required,
aria-selected, приводит к усложнению и увеличению веса селектора.
Дублировать disabled и checked в aria-disabled и aria-checked нет смысла.

Предпочтительней не ориентировать визуальное состояние на ARIA-атрибуты, и размещать наименования состояни
в атрибут Элемента (my-class) в качестве значений, возможно группировать view и state
1.0 и 2.0: `-viewName--stateName-`,
3.0: `{v-name}{s-name}`
3.1.1 `v-name s-name`

Селекторы могут выглядеть следующим образом:
```css
/* iAMcss 1.0 */
.my-iTree[role = "treeitem"][aria-expanded = "true"] {}
.my-iTreeTooltip[x-hoverlabel]:hover {}
.my-iMenu.my-iTreeTooltip[x-hoverlabel]:hover {} /* доп. контекст дедушкиного блока см. Миксы */
.my-iMenu.[x-hoverlabel]:hover {} /* но надо быть проще и ограничиваться рамками одного блока */
.my-iTreeTooltip[x-hoverlabel *= "-loading-"] {}

/* iAMcss 1.1 "inverted" */
.leaf[x-mas-tree][aria-expanded = "true"] {}
.hoverlabel[x-mas-tree-tooltip]:hover {}
.hoverlabel[x-mas-tree-tooltip][my-menu]:hover {} /* доп. контекст дедушкиного блока см. Миксы */
.hoverlabel[x-mas-menu]:hover {} /* но надо быть проще и ограничиваться рамками одного блока */
.hoverlabel[x-mas-tree-tooltip *= -loading-] {}

/* iAMcss 2.0 */
*[data-my-tree__item][aria-expanded = "true"] {}
*[data-my-tree-tooltip__hoverlabel]:hover {}
*[data-my-tree-tooltip__hoverlabel *= "^my-menu^"]:hover {} /* доп. контекст дедушкиного блока см. Миксы */
*[data-my-menu__hoverlabel]:hover {} /* но надо быть проще и ограничиваться рамками одного блока */
*[data-my-tree-tooltip__hoverlabel *= -loading-] {}

/* iAMcss 2.2 */
*[x-item *= "^my-tree^"][aria-expanded = "true"]{}
*[x-hoverlabel *= "^my-tree-tooltip^"]:hover {}
*[x-hoverlabel *= "^my-menu^^my-tree-tooltip^"]:hover {} /* доп. контекст дедушкиного блока см. Миксы */
*[x-hoverlabel *= "^my-menu^"]:hover {} /* но надо быть проще и ограничиваться рамками одного блока */
*[x-hoverlabel *= "^my-tree-tooltip^"][x-hoverlabel *= "-loading-"] {}
*[x-hoverlabel *= "^my-tree-tooltip^-loading-"] {} /* если state, которых много, идёт строго за контекстом блока */

/* iAMcss 3.0 */
[iam-tree-item][aria-expanded = true] {}
[iam-tree-tooltip-hoverlabel]:hover {}
[iam-tree-tooltip-hoverlabel ~= iam-menu]:hover {}
[iam-menu-hoverlabel]:hover {}
[iam-tree-tooltip-hoverlabel ~= loading]
```

Необходимо понимать, что составные селекторы наращивают специфичность, старайтесь придерживаться
минимальной специфичности (либо какой-то базовой), чтобы при написании переопределяемого селектора
не приходилось искуственно наращивать специфичность. v3 наименее специфичен.

## Модификатор темы (skin) / view
Если раньше мы писали что-то типа `.dark .myNumberInputLabel`,
то теперь, используя возможности [css-variables](https://medium.com/front-end-weekly/theming-with-css-variables-e4f30343c7c7)
(для ie11 [polyfill](https://github.com/nuxodin/ie11CustomProperties), [тест](https://jsbin.com/dapunoquyo/1/)) пишем:
```css
.sknLight { --t-primary-color: black; } /* Тема по умолчанию */ 
.sknDark { --t-primary-color: white; }

/* iAMcss 1.0 */
.my-iInput[type = "number"] { color: var(--t-primary-color); }

/* iAMcss 2.0 */
*[data-my-input][type = "number"] { color: var(--t-primary-color); }

/* iAMcss 3.1.1 */
*[iam-input][type = number] { color: var(--t-primary-color); }
```
В модификаторах "темы" может быть нэйминг не только касающийся цветовой палитры,
но и версии, ориентация (горизонтальная/вертикальная) и прочее.

### Состояние по умолчанию / undefined

Даже в случае если у вас элемент имеет всего два состояния, рекомендуется прописывать оба,
а не определять оформление элемента по умолчанию + переопределять эти же свойства в контексте
одного из состояний. В качестве исключения можно назвать состояния с использованием стандартизированных
атрибутов `:disabled` и `:checked`, управление которыми заключается в их добавлении/удалении.
При наличии модификатора базового состояния, его toggle будет замещать модификатор нового состояния
в предсказуемом месте. В противном случае модификаторы будут как на конвейере перепрописываться в конец
атрибута.
Разумеется любую рекомендацию вы можете игнорировать ;)

## Миксы
[Миксы](https://ru.bem.info/methodology/quick-start/#Микс) возможно реализовать только при помощи
html-атрибутов (или их значений), поскольку каждый DOM-элемент обязан иметь одно конкретное имя
html-тэга, а не множество, тогда как на одном тэге можно разместить большое количество всевозможных
атрибутов, благодаря чему и реализовать микс.

Следует особенно задуматься в тот момент, когда у вас среди селекторов вдруг появляется
множественный класс или несколько контекстных блоков, одного уровня.
```css
/* iAMcss 1.0 */
.my-iTree.my-iTooltip

/* iAMcss 2.2 */
*[x-hoverlabel *= "^my-tree^"][x-hoverlabel *= "^my-tooltip^"]
```
скорей всего вы проектируете что-то не так. Микс подразумевает под собой расположение признаков
(классов или атрибутов) на одной DOM-ноде прежде всего для того, чтобы написать селектор с
одним из этих признаков (семантичное разделение разного функционала), а не с несколькими,
и при том сэкономить на DOM-элементах (предназначенных только для визуального оформления)
уменьшив глубину DOM-дерева.

В примере, показанном выше, решением является создание нового блока `.my-iTreeTooltip, *[x-hoverlabel *= "^my-tree-tooltip^"]`. Но при необходимости вполне допускается указывать дополнительный контекст,
старшего родителя: `.my-iMenu.my-iTreeTooltip, *[x-hoverlabel *= "^my-menu^^my-tree-tooltip^"]`,
который тоже можно свести к созданию нового блока.
Опять же, следует понимать, что создание нового блока на миксе, потребует дополнительного времени
по копи-пастингу состояний в соответствующие атрибуты элементов.

С точки зрения iAMcss, миксы являются аналогом множественного наследования интерфейсов в ООП.
Реализация миксов по iAMcss 1.0 и 2.0 несколько различается: в первом случае это набор iКлассов
в атрибуте "class", во втором случае это набор атрибутов на одной html-ноде.

Поскольку миксы рассматриваются как множественное наследование перечислением интерфейсов, то в идеале,
во избежание коллизий и работы со специфичностью селекторов, селекторы `.iClassA[holder] и iClassB[holder]`
(или `*[class-a__holder]` и `*[class-b__holder]`) не должны определять
одинаковые css-свойства, либо эти блоки не должны быть замиксованы вместе на одной DOM-ноде.
Миксы не рекомендуется использовать для доопределения тех или иных свойств элемента, для этого предназначены модификаторы.

ВАЖНО!
В БЭМе миксы используют для того чтобы отделить общие layout-правила (отвечающие за различные размеры и отступы элементов
внутри контейнера) от оформления контейнера которое зависит от того в каком родительском блоке/элементе он находится.
Смотри уже устаревшие [holder/layout блоки](http://vitaly.harisov.name/article/independent-blocks.html),
которые претерпели изменени в рамках методологии БЭМ. Ныне блок миксуется в качестве элемента другого блока, например (смотри dt):
```html
<dl iam-popup="-wgtCountries-">
	<dt iam-h="iam-popup sknDark h3" iam-popup__title="spcNormal">Popup title</dt>
	<dd iam-popup__content>Some content</dd>
</dl>
```
```css
*[iam-popup__title ~= spcNormal]{
	line-height: 2em;
}
```

## Валидность
Если вы любитель [кнопок-бэйджиков от W3C](https://www.w3.org/QA/Tools/Icons), то наверное знаете,
что стандартом HTML5 допускаются помимо WAI-ARIA и стандартных атрибутов
[data- атрибуты](https://www.w3.org/TR/2014/REC-html5-20141028/dom.html#attr-data-*),
остальные атрибуты считаются инвалидными ;)

Если использовать XHTML или XML, то у вас не будет этого ограничения, и вы не обязаны будете каждый
свой атрибут (да ещё и с префиксом) предварять префиксом data-. Как вариант, можно вообще
игнорировать тот факт, что код у вас не совсем валидный, и для удобочитаемости [опускать
префиксы data-](https://habrahabr.ru/post/139210/#comment_4652461). Только необходимо помнить о том,
что вы работаете в глобальном пространстве имён, и, чтобы случайно не пересечься с каким-либо сторонним
фреймворком, его необходимо сужать введением своих префиксов (например проекта/организации).

## JS-хуки.
Для получения необходимого объекта вместо getElementById вызывайте querySelectorAll с заранее известной DOM-ноды,
чтобы сузить область срабатывания селектора. Используйте селектор `*[iam-id *= wgtId]`.

Параметр для querySelectorAll не должен быть
динамически собираемым, чтобы ваш код легко был распознан верстальщиком. Верстальщик при
изменении селекторов в CSS-файлах обязан также проверять и JS код на наличие CSS-подобных
селекторов в querySelectarAll, потому для JS не требуется заводить дублирующий data-атрибут,
который в других методологиях призван отделить работу js от представления.
Сам же JS-код не должен менять стили программно, он обязан только управлять сменой
[состояний](#Состояние) элемента/блока.

## Префиксы
Валидными custom атрибутами считаются те, что начинаются с префиксов "data-" и "x-".
Если так важна валидность используйте автоматизирующие вашу работу инструменты.
Можно не возвеличивать валидность и в качестве префиксов атрибутов использовать свои наименования.

## Каскадирование и контекст
В целом каскад [не одобряется](https://ru.bem.info/faq/#Почему-нежелательно-использовать-вложенные-селекторы),
хотя бы потому, что вам самим неудобно работать с селекторами
сторонних фреймворков, которые переопределяют оформление вашего элемента. Но если вам
уж сильно не хочется на каждый li и td вешать атрибуты/классы вашего элемента/блока, то
в случае со списком вместо `.my-iList li` предпочтите запись `.my-iList > li` выставив
класс на каждый ul/ol/dl, но помните, когда вам потом понадобится управлять самим li,
вы будете иметь на него влияние ранее написанного каскадного селектора, и в сложных случаях
селекторы [могут ломаться](https://habrahabr.ru/post/270075/#comment_8641367) из-за появления промежуточных dom-элементов.
Случай с таблицей особенный. По идее времена, когда верстали вложенные таблицы, прошли
(теперь семантично верстают вложенными списками ;)) и можно вполне допустить использование `.my-iTable th`,
но лучше `.my-iTable__row > th`. Если вешать атрибуты, чтобы привязать оформление на каждую ячейку, то по iAMcss 1.0
плучили бы следующий селектор: `.my-iTable[data-cell *= '-header-']`, 
по iAMcss 2.2 `*[x-cell *= "^my-table^"][x-cell *= "-header-"]`,
по iAMcss 3.1.1 `[iam-table-cell ~= header]`

Если мы хотим использовать стандартные контролы и не прописывать всё поведение с нуля
(например свои чекбоксы с состояниями disabled, checked), то никуда не деться от повышения
специфичности селектора. Написание кода по iAMcss не должно противоречить современным техникам,
например таким как [css3 checkbox/radio hack](Если мы хотим использовать стандартные контролы и не прописывать всё поведение с нуля
(например свои чекбоксы с состояниями disabled)).

Каскад `.class1 .class2` (через пробел) это то, от чего мы стремимся уйти,
оправдан только как костыль для экономии времени на перебрасывании контекста состояния родительского
элемента в дочерний.

## Актуальная, наиболее упрощенная версия 3.1
[Краткая выжимка](https://github.com/viT-1/iAMcss/blob/master/v3/styleguide.md) по iAMCss v3

## Примеры кода
- Кнопки простые и [кнопки с выпадающим списком](https://vit-1.github.io/iAMcss-samples/v3/iconed-buttons/) по iAMcss 3.1.1 ([код 2021.08.25](https://github.com/viT-1/iAMcss-samples/tree/360e148c638d3d327ae2b3ebfe272abeedf12385/v3/iconed-buttons))
- Тулбар с применением checkbox-hack в соседстве с ARIA-атрибутами, сложные селекторы [по iAMcss 2.0](https://codepen.io/viT-1/pen/KXyyGM) (2017.10.09)
- Обновлённый пример [тулбара с ARIA-атрибутами](https://vit-1.github.io/iAMcss-samples/v3/aria-collapsable/) по iAMcss 3.1.1 ([код 2021.09.15](https://github.com/viT-1/iAMcss-samples/tree/3c69e346a0aaee4701d1f887e95510966674b3fb/v3/aria-collapsable))
- Микс кнопки и выпадающего списка, не столь актуальный с учётом предыдущих два примера, зато [по iAMcss 1.0](http://codepen.io/viT-1/pen/VjXybd) (2016.12.08)
- [FontAwesome чекбоксы/радио-кнопки](http://codepen.io/viT-1/pen/GrBwbE) с применением iAMcss 2.0 и поддержкой клавиатуры (2017.02.15)
- Виджет vp-tree__list JSON [по iAMcss 2.0](https://codepen.io/viT-1/pen/XVxEgX) и <del title="ico sources broken">SVG-иконками</del> разных размеров (2018.01.18)
- [iam-tree-list](https://vit-1.github.io/iAMcss-samples/v3/json-tree/) JSON по iAMcss 3.1.1 ([код 2021.09.17](https://github.com/viT-1/iAMcss-samples/tree/03de30ba3c252afdec146d49530bcedadb22a565/v3/json-tree))
- [iam-tree-list XSLT + IE8](https://vit-1.github.io/iAMcss-samples/v3/xml-tree/) (2018.01.24)
- [Стилизованный select](https://vit-1.github.io/iAMcss-samples/v3/pure-css-select/) с применением checkbox-hack и возможностью группировки. JS только для обеспечения закрытия/раскрытия списка по клику на item или placeholder. CSS-флаги стран. ([код 2021.09.21](https://github.com/viT-1/iAMcss-samples/tree/b58077b27c4ed8581e680d04b4384144749de65d/v3/pure-css-select))