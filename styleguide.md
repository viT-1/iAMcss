# iAMcss styleguide

## Вступление
iAMcss не является самостоятельной методологией, это всего лишь нотация,
набор соглашений, призванных облегчить написание и сопровождение css-правил.
Соответственно никакого js-движка, использования утилит по сборке не требуется,
никаких требований по организации структуры папок и файлов iAMcss не предъявляет.

iAMcss лишь упорядочивает вашу работу по написанию  и использованию css-селекторов,
соответственно вы можете применять эту нотацию в любых фреймворках, вёрстку
которых Вам удобно будет поправить.

##iAMcss = БЭМ + AMCSS

iAMcss следует методологии БЭМ. БЭМ оперирует тремя основными понятиями:
Блок, Элемент, Модификатор. С модификатором всё понятно, по БЭМу он
[определяется](https://ru.bem.info/methodology/quick-start/#Модификатор) так:
модификатор - сущность, определяющая внешний вид, состояние или поведение блока
либо элемента.

С разделением понятий Блок и Элемент всё гораздо сложнее. Очень часто начинающие БЭМеры
совершают [много ошибок](https://habrahabr.ru/post/305548/), и это нормальное положение
дел, так как верстальщики и js-программисты при работе с HTML-разметкой привыкли
оперировать понятием DOM-элемент (тэг). И действительно, чтобы не путать,
где блок, а где элемент, где простой блок (похожий на элемент), а где составной,
гораздо яснее было бы пользоваться понятием Абсолютно Независимого Блока
(подобное положение дел высказывалось [на хабре](https://habrahabr.ru/post/203994/)).

Чтобы уйти от этой путаницы, которую архитекторы БЭМа
[заложили в основании БЭМа](https://ru.bem.info/methodology/quick-start/#Когда-создавать-блок-когда-элемент),
iAMcss предлагает пользоваться следующими понятиями: Interface, Attribute, Modificator.
Ставку делаем на [селекторы атрибутов CSS 2.1](http://caniuse.com/#feat=css-sel2)!
(в своё время БЭМеры [отказались](https://ru.bem.info/forum/-68/#comment-) от этой затеи)

Гугл, кстати, решил уйти от блоков, и [опирается на элементы](https://habrahabr.ru/company/dataart/blog/270109/),
что, без предварительной сборки препроцессорами, возвращает нас к проблемам которые
был призван решить БЭМ: например css-каскадирование, использующееся для того чтобы
отличить один элемент от такого же элемента, но имеющего другой уровень вложенности.

##Interface
Interface - абстрактное понятие [как в классическом ООП](https://habrahabr.ru/post/30444/),
определяющее набор свойств/функций объекта, но не его реализацию. Не путать с визуальным интерфейсом!

В БЭМе аналогия Interface это "[Блок](https://ru.bem.info/methodology/quick-start/#Блок)".
По сути БЭМу "[Блок](https://ru.bem.info/methodology/quick-start/#Блок)" необходим с той же целью,
с какой используется понятие interface в ООП: для того чтобы отделить одну функциональность от другой
и сгруппировать воедино все составляющие части этой функциональности.

Interface можно рассматривать как prefix/namespace для "Элемента", как группирующая метка имён элементов
подчиняющихся одной функциональности. Например классом iDropDownList по iAMcss 1.0 помечены и кнопка
инициирующая отображение полного списка вариантов выбора, и общий контейнер содержащий эту кнопку,
и текстовое поле с выбором.

В нотации iAMcss 1.0 интерфейс обязательно должен быть прописан как iClass в html-атрибуте "class"
каждого DOM-элемента вместе составляющих единое целое (отвечающих за одну функциональность).
Не должно быть селекторов типа ".iClass {}", поскольку интерфейс это объединяющее абстрактное понятие,
а не реальное, принадлежащее конкретной DOM-ноде!

В нотации iAMcss 2.0 именование блока размещено в виде префикса как часть именования атрибута (элемента).

К чему же тогда должны быть привязаны CSS-селекторы? Если продолжать аналогию с ООП,
то реализацией/классом по iAMcss является конкретная DOM-нода, она же "элемент" (по БЭМ),
соответственно селекторы должны основываться на атрибутах размещённых на DOM-элементах.

##Attribute
Attribute - основа реализации селекторов по iAMcss как преемника [AMCSS](https://amcss.github.io/).
Атрибут в iAMcss аналогичен понятию "[Элемент](https://ru.bem.info/methodology/quick-start/#Элемент)" в БЭМ.
HTML-атрибут используется в iAMcss для ссылки на конкретный DOM-элемент с которым мы будем работать
(опеределять js-поведение и оформление), он помогает усилить специфичность селектора конкретного тэга.

Почему не пользуемся для этих целей атрибутом "class" пояснено в следующем параграфе. Помимо этого
атрибуты позволяют разложить все модификаторы по своим полочкам, что особенно актуально в случае миксов
и при сложных наборах состояний элемента.

Такова эволюция CSS-селекторов HTML-разметки:
- до CSS ([html3](http://citforum.ru/internet/html3.2ex/all.shtml)) оформление размещали в множестве
атрибутов (align, bgcolor, width...)
- затем из атрибутов оформление вынесли в inline-стили
- затем вынесли оформление в отдельный файл, css-селекторы которого основывались на атрибуте "class"
и на именовании тэгов
- после того как атрибут класс был облюбован множеством фреймворков, js-хуков и метками микроданных,
разработчикам, во избежание коллизий, пришлось уводить селекторы в custom data-attributes
- в идеале нас ждёт переход на [веб-компоненты](http://stackoverflow.com/questions/9845011/are-custom-elements-valid-html5#answer-9845124),
Google уже [перешёл](https://material.angularjs.org/latest/CSS/button)!

iAMcss при работе со стандартными атрибутами (в т. ч. ARIA) не требует фанатичного соблюдения
правила, что в значениях атрибута должно размещаться только его значение-модификатор.
Пример такого отступления от правил:
```css
/* iAMcss 1.0 */
.my-iTree[role = 'treeitem'] {} /* с использованием aria */
.my-iTree[data-item] {} /* без использования aria, свой valid HTML "велосипед" */

/* iAMcss 2.0 */
*[data-my-i-tree__item] {}
*[iam-tree--item] {}
```

##Modificator
Modificator - Cущность, доопределяющая внешний вид (view) или поведение элемента. Состояния являются
одним из видов модификаторов и описаны подробнее ниже.
В сравнении с БЭМ'ом, для простоты восприятия, в определении исключено упоминание о "Блоке".
Блок/интерфейс не может иметь модификатор, тогда как контейнер блока (соответствующий элемент) может.

Именование view следует оканчивать символом '-'.

Имя модификатора размещается в значении атрибута, и тем самым iAMcss решает ту же
проблему, что и [CSS-modules](https://github.com/css-modules/css-modules): даёт возможность иметь базу
(селектор атрибута) и доопределять элемент при помощи селектора атрибута с его значением,
не создавая для этого дополнительный класс (как это делает БЭМ).

iAMcss перед реализацией БЭМа, использующей атрибут class, имеет синтаксическое преимущество:
отсутствие дублирующей громоздкой строки с путём до элемента предваряющей значение модификатора.
К тому же, в случае миксов, разметка HTML по БЭМу превращается в свалку длинных наименований классов,
тогда как по iAMcss все модификаторы сгруппированы по своим атрибутам (при том их будет несколько).

Для декларации модификатора, которым следует пользоваться всем элементам микса, возможно использование
атрибута "class" - это будет "общак" ;) Не забывайте, что "class" скорей всего используется и другими
фреймворками, потому добавляйте к наименованию модификатора namespace (префикс проекта/организации).

##Состояние
Состояние - сущность-признак отвечающая за отображение элемента и в целом блока (состояние блока задаёт
контекст отображения элементов блока), в отличие от модификаторов, динамически изменяется.
Элемент/контейнер блока может находится сразу в нескольких состояниях.

Состояния, в отличии от модификаторов, могут иметь одни и те же названия в разных блоках и элементах,
уникальность селектора гарантируется за счёт указания имени блока и элемента. Конечно можно описывать
состояния не привязываясь к конкретному блоку, но необходимо помнить, что css-свойства в таком селекторе
скорее всего для конкретного блока прийдётся переопределять.

Приветствуется использование стандартного способа указания состояния при помощи стандартных
атрибутов или [WAI ARIA](https://www.w3.org/WAI/ARIA/project), таких как disabled, checked, hidden, readonly,
required, aria-busy, aria-expanded, aria-grabbed, aria-invalid, aria-pressed, aria-readonly, aria-required,
aria-selected. Дублировать disabled и checked в aria-disabled и aria-checked нет смысла.

В случае, если вы придумываете свои состояния и размещаете их в атрибут Элемента (my-iClass) в качестве
значений, то начинать именование состояния следует с символа '-'. Таким образом, при необходимости,
можно группировать view и state как значение viewName-stateName или other_view_name-other_state_name.

Селекторы могут выглядеть следующим образом:
```css
/* iAMcss 1.0 */
.my-iTree[role = 'treeitem'][aria-expanded = 'true'] {}
.my-iTreeTooltip[role = 'treeitem']:hover {}

/* iAMcss 2.0 */
*[data-my-tree__item][aria-expanded = 'true'] {}
*[data-my-tree-tooltip]:hover {}
*[data-my-tree-tooltip *= '-loading'] {}
```

###Состояние по умолчанию / undefined

Даже в случае если у вас элемент имеет всего два состояния, рекомендуется прописывать оба,
а не определять оформление элемента по умолчанию + переопределять эти же свойства в контексте
одного из состояний. В качестве исключения можно назвать состояния "[disabled]" и "[checked]",
управление которыми заключается в добавлении/удалении данных атрибутов. Разумеется эту рекомендацию
вы можете игнорировать ;)

##Миксы
[Миксы](https://ru.bem.info/methodology/quick-start/#Микс) возможно реализовать только при помощи
html-атрибутов (или их значений), поскольку каждый DOM-элемент обязан иметь одно конкретное имя
html-тэга, а не множество, тогда как на одном тэге можно разместить большое количество всевозможных
атрибутов, благодаря чему и реализовать микс.

С точки зрения iAMcss, миксы являются аналогом множественного наследования интерфейсов в ООП.
Реализация миксов по iAMcss 1.0 и 2.0 несколько различается: в первом случае это набор iКлассов
в атрибуте "class", во втором случае это набор атрибутов на одной html-ноде.

Поскольку миксы рассматриваются как множественное наследование перечислением интерфейсов, то в идеале,
во избежание коллизий и работы со специфичностью селекторов, селекторы .iClassA[container] и iClassB[container]
(или *[iClassA__container] и *[iClassB__container]) не должны определять
одинаковые css-свойства, либо эти блоки не должны быть замиксованы вместе.
Миксы не рекомендуется использовать для доопределения тех или иных свойств элемента, для этого предназначены модификаторы.

По возможности избегайте миксов, и вам легче будет перейти на разработку веб-компонент,
и соответственно легче перенести в их стили селекторы написанные в нотации iAMcss.

##Валидность
Если вы любитель [кнопок-бэйджиков от W3C](https://www.w3.org/QA/Tools/Icons), то наверное знаете,
что стандартом HTML5 допускаются помимо WAI-ARIA и стандартных атрибутов
[data- атрибуты](https://www.w3.org/TR/2014/REC-html5-20141028/dom.html#attr-data-*),
остальные атрибуты считаются инвалидными ;)

Если использовать XHTML или XML, то у вас не будет этого ограничения, и вы не обязаны будете каждый
свой атрибут (да ещё и с префиксом) предварять префиксом "data-". Как вариант, можно вообще
игнорировать тот факт, что код у вас не совсем валидный, и для удобочитаемости [опускать
префиксы data-](https://habrahabr.ru/post/139210/#comment_4652461). Только необходимо помнить о том,
что вы работаете в глобальном пространстве имён, и, чтобы случайно не пересечься с каким-либо сторонним
фреймворком, его необходимо сужать введением своих префиксов (например проекта/организации).

##JS-хуки.
Для получения необходимого объекта вызывайте querySelectorAll с заранее известной DOM-ноды,
чтобы сузить область срабатывания селектора. Параметр для querySelectorAll не должен быть
динамически собираемым, чтобы ваш код легко был распознан верстальщиком. Верстальщик при
изменении селекторов в CSS-файлах обязан также проверять и JS код на наличие CSS-подобных
селекторов в querySelectarAll, потому для JS не требуется заводить дублирующий data-атрибут,
который в других методологиях призван отделить работу js от представления.
Сам же JS-код не должен менять стили программно, он обязан только управлять сменой
[состояний](#Состояние) элемента/блока.

##Префиксы

##Каскадирование и контекст
В целом каскад [не одобряется](https://ru.bem.info/faq/#Почему-нежелательно-использовать-вложенные-селекторы),
хотя бы потому, что вам самим неудобно работать с селекторами
сторонних фреймворков, которые переопределяют оформление вашего элемента. Но если вам
уж сильно не хочется на каждый li и td вешать атрибуты/классы вашего элемента/блока, то
в случае со списком вместо ".my-iList li" предпочтите запись ".my-iList > li" выставив
класс на каждый ul/ol/dl, но помните, когда вам потом понадобится управлять самим li,
вы будете иметь на него влияние ранее написанного каскадного селектора, и в сложных случаях
селекторы [могут ломаться](https://habrahabr.ru/post/270075/#comment_8641367) из-за появления промежуточных dom-элементов.
Случай с таблицей особенный, по идее времена, когда верстали вложенные таблицы прошли
(теперь семантично верстают вложенными списками ;)) и можно вполне допустить использование ".my-iTable td",
но лучше ".my-iTable__row > td".

Если мы хотим использовать стандартные контролы и не прописывать всё поведение с нуля
(например свои чекбоксы с состояниями disabled, checked), то никуда не деться от повышения
специфичности селектора. Написание кода по iAMcss не должно противоречить современным техникам,
например таким как [css3 checkbox/radio hack](Если мы хотим использовать стандартные контролы и не прописывать всё поведение с нуля
(например свои чекбоксы с состояниями disabled)).

Каскад ".class1 .class2" (через пробел) оправдан только для работы с контекстом состояния родительского
элемента, но при том рекомендуется чтобы ".class2" являлся атрибутивным селектором iAMcss.
Если вы вынуждены громоздить такие цепочки только с целью повысить специфичность
селектора (перекрыть стили от фреймворка например), то значит уже что-то в вашем коде не так,
и вам лучше создать новый элемент (например как в [случае с iam-star](http://codepen.io/viT-1/pen/GrBwbE)).

Для наглядности каждую часть селектора следует писать на новой строке. [Пример](http://codepen.io/viT-1/pen/GrBwbE).

##Преимущества и недостатки версий iAMcss 1.0 и 2.0
В iAMcss 1.0 проще работать со стандартными атрибутами (в т.ч. ARIA), так как можно опираться
на них как есть, помечая свои "блоки" классом. Также, в случае миксов, для написания селекторов
можно пользоваться одними и теми же атрибутами (как своими, так и стандартными). С одной стороны
такой подход сокращает количество атрибутов на DOM-элементе, а с другой стороны не далеко уходит
от стилистики маркировки элементов до БЭМа - всё в class.

iAMcss 1.0 эволюционировал в iAMcss 2.0 только по одной причине: каждый модификатор элемента должен
относится к конкретному блоку, потому пришлось перенести именование блока из атрибута "class"
в префикс атрибута относящегося к элементу. Если у вас есть необходимость чётко
разделять элементы и их модификаторы разных блок-интерфейсов по разным атрибутам, то пользуйтесь
нотацией iAMcss 2.0.

В iAMcss 2.0 самое главное ограничение внешнее: названия атрибутов обязаны быть написаны
в нижнем регистре. Соответственно [Венгерскю нотацию](https://ru.wikipedia.org/wiki/%D0%92%D0%B5%D0%BD%D0%B3%D0%B5%D1%80%D1%81%D0%BA%D0%B0%D1%8F_%D0%BD%D0%BE%D1%82%D0%B0%D1%86%D0%B8%D1%8F)
использовать не получится и, в случае сложных именований мы вынуждены будем использовать символы "-" и "_".

В iAMcss 2.0 позволяется использовать атрибут "class" для размещения глобальных модификаторов,
например "my-animated", соответственно можно использовать для нескольких блоков расположенных
на одном DOM-элементе единые состояния, которые, впрочем, можно вынести и в отдельные атрибуты.

##Примеры кода
- Сравнительная вёрстка [БЭМ, iAMcss 1.0 и iAMcss 2.0](http://codepen.io/viT-1/pen/RKbXwE).
- Сложный [микс кнопки и выпадающего списка](http://codepen.io/viT-1/pen/VjXybd) по iAMcss 1.0
- [FontAwesome чекбоксы/радио-кнопки](http://codepen.io/viT-1/pen/GrBwbE) с применением iAMcss 2.0 и поддержкой клавиатуры