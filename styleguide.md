# iAMcss styleguide

## Вступление
iAMcss не является самостоятельной методологией, это всего лишь нотация,
набор соглашений, призванных облегчить написание и сопровождение css-правил.
Соответственно никакого js-движка, использования утилит по сборке не требуется,
никаких требований по организации структуры папок и файлов iAMcss не предъявляет.

iAMcss лишь упорядочивает вашу работу по написанию  и использованию css-селекторов,
соответственно вы можете применять эту нотацию в любых фреймворках, вёрстку
которых Вам удобно будет поправить.

##iAMcss = БЭМ + AMCSS

iAMcss следует методологии БЭМ. БЭМ оперирует тремя основными понятиями:
Блок, Элемент, Модификатор. С модификатором всё понятно, по БЭМу он
[определяется](https://ru.bem.info/methodology/quick-start/#Модификатор) так:
модификатор - сущность, определяющая внешний вид, состояние или поведение блока
либо элемента.

С разделением понятий Блок и Элемент всё гораздо сложнее. Очень часто начинающие БЭМеры
совершают [много ошибок](https://habrahabr.ru/post/305548/), и это нормальное положение
дел, так как верстальщики и js-программисты при работе с HTML-разметкой привыкли
оперировать понятием DOM-элемент (тэг). И действительно, чтобы не путать,
где блок, а где элемент, где простой блок (похожий на элемент), а где составной,
гораздо яснее было бы пользоваться понятием Абсолютно Независимого Блока
(подобное положение дел высказывалось [на хабре](https://habrahabr.ru/post/203994/)).

Чтобы уйти от этой путаницы, которую архитекторы БЭМа
[заложили в основании БЭМа](https://ru.bem.info/methodology/quick-start/#Когда-создавать-блок-когда-элемент),
iAMcss предлагает пользоваться следующими понятиями: Interface, Attribute, Modificator.
Ставку делаем на [селекторы атрибутов CSS 2.1](http://caniuse.com/#feat=css-sel2)!
(в своё время БЭМеры [отказались](https://ru.bem.info/forum/-68/#comment-) от этой затеи)

Гугл, кстати, решил уйти от блоков, и [опирается на элементы](https://habrahabr.ru/company/dataart/blog/270109/),
что, без предварительной сборки препроцессорами, возвращает нас к проблемам которые
был призван решить БЭМ: например css-каскадирование, использующееся для того чтобы
отличить один элемент от такого же элемента, но имеющего другой уровень вложенности.

##Interface
Interface - абстрактное понятие [как в классическом ООП](https://habrahabr.ru/post/30444/),
определяющее набор свойств/функций объекта, но не его реализацию. Не путать с визуальным интерфейсом!

В БЭМе аналогия Interface это "[Блок](https://ru.bem.info/methodology/quick-start/#Блок)".
По сути БЭМу "[Блок](https://ru.bem.info/methodology/quick-start/#Блок)" необходим с той же целью,
с какой используется понятие interface в ООП: для того чтобы отделить одну функциональность от другой
и сгруппировать воедино все составляющие части этой функциональности.

Interface можно рассматривать как prefix/namespace для "Элемента", как группирующая метка имён элементов
подчиняющихся одной функциональности. Например классом iDropDownList по iAMcss 1.0 помечены и кнопка
инициирующая отображение полного списка вариантов выбора, и общий контейнер содержащий эту кнопку,
и текстовое поле с выбором.

В нотации iAMcss 1.0 интерфейс обязательно должен быть прописан как iClass в html-атрибуте "class"
каждого DOM-элемента вместе составляющих единое целое (отвечающих за одну функциональность).
Не должно быть селекторов типа `.iClass {}`, поскольку интерфейс это объединяющее абстрактное понятие,
а не реальное, принадлежащее конкретной DOM-ноде!

В нотации iAMcss 2.0 именование блока размещено в виде префикса как часть именования атрибута (элемента).
Атрибуты регистронезависимы, соответственно используем нижний регистр и символы "_" и "-".

К чему же тогда должны быть привязаны CSS-селекторы? Если продолжать аналогию с ООП,
то реализацией/классом по iAMcss является конкретная DOM-нода, она же "элемент" (по БЭМ),
соответственно селекторы должны основываться на атрибутах размещённых на DOM-элементах.

##Attribute
Attribute - основа реализации селекторов по iAMcss как преемника [AMCSS](https://amcss.github.io/).
Атрибут в iAMcss аналогичен понятию "[Элемент](https://ru.bem.info/methodology/quick-start/#Элемент)" в БЭМ.
HTML-атрибут используется в iAMcss для ссылки на конкретный DOM-элемент с которым предстоит работать
(опеределять js-поведение и оформление).

Почему не пользуемся для этих целей атрибутом "class" пояснено в следующем параграфе. Помимо этого
атрибуты позволяют разложить все модификаторы по своим полочкам, что особенно актуально в случае миксов
и при сложных наборах состояний элемента.

Такова эволюция CSS-селекторов HTML-разметки:
- до CSS ([html3](http://citforum.ru/internet/html3.2ex/all.shtml)) оформление размещали в множестве
атрибутов (align, bgcolor, width...)
- затем из атрибутов оформление вынесли в inline-стили
- затем вынесли оформление в отдельный файл, css-селекторы которого основывались на атрибуте "class"
и на именовании тэгов
- после того как атрибут класс был облюбован множеством фреймворков, js-хуков и метками микроданных,
разработчикам, во избежание коллизий, пришлось уводить селекторы в custom data-attributes
- в идеале нас ждёт переход на [веб-компоненты](http://stackoverflow.com/questions/9845011/are-custom-elements-valid-html5#answer-9845124),
Google уже [перешёл](https://material.angularjs.org/latest/CSS/button)!

iAMcss при работе со стандартными атрибутами (в т. ч. ARIA) не требует фанатичного соблюдения
правила, что в значениях атрибута должно размещаться только его значение-модификатор.
Пример такого отступления от правил:
```css
/* iAMcss 1.0 */
.my-iTree[role = 'treeitem'] {} /* с использованием aria */
.my-iTree[data-item] {} /* без использования aria, свой valid HTML "велосипед" */

/* iAMcss 2.0 */
*[data-my-i-tree__item] {}
*[iam-tree--item] {}
```

##Modificator
Modificator - Cущность, доопределяющая внешний вид (view) или поведение элемента. Состояния являются
одним из видов модификаторов и описаны подробнее ниже.
В сравнении с БЭМ'ом, для простоты восприятия, в определении исключено упоминание о "Блоке".
Блок/интерфейс не может иметь модификатор, тогда как контейнер блока (соответствующий элемент) может.
Корневой контейнер, в котором располагаются все элементы "блока" может называться holder'ом,
либо, если этот контейнер объединяет множество элементов, может называться list или items.
Например:
```css
/* iAMcss 1.0 */
.my-tree[x-list] {}

/* iAMcss 2.0 */
*[x-tree__list]
```

Имя модификатора размещается в значении атрибута, и тем самым iAMcss решает ту же
проблему, что и [CSS-modules](https://github.com/css-modules/css-modules): даёт возможность иметь базу
(селектор атрибута) и доопределять элемент при помощи селектора атрибута с его значением,
не создавая для этого дополнительный класс (как это делает БЭМ).

Для тонкой настройки конкретного экземпляра реиспользуемого блока, вместо того чтобы использовать
селектор #myId, чтобы вес селектора остался минимальным, рекомендуется в список модификаторов
для каждого элемента добавлять один и тот же идентификатор виджета.

Чтобы использовать CSS3 селекторы без ошибок, рекомендуется именования модефикаторов оборачивать
в начале и конце символом "-" либо "_" (только их разрешается использовать в селекторах без кавычек).
Разделять модификаторы пробелами нет необходимости. Чтобы не увеличивать вес селектора, можно
комбинировать соседние модификаторы, например:

```css
/* iAMcss 2.0 */
*[my-combobox__item *= -sknDark-]{
	color: var(--sknDarkClrBaseFrnt);
}

*[my-combobox__item *= -spcMinimal-]{
	margin: 0;
	padding: 0;
	line-height: 1.2em;
}

*[my-combobox__item *= -wgtCounries--spcMinimal-]{
	width: 200px;
}
```

iAMcss перед реализацией БЭМа, использующей атрибут class, имеет синтаксическое преимущество:
отсутствие дублирующей громоздкой строки с путём до элемента предваряющей значение модификатора.
К тому же, в случае миксов, разметка HTML по БЭМу превращается в свалку длинных наименований классов,
тогда как по iAMcss все модификаторы сгруппированы по своим атрибутам (при том их будет несколько).

Для декларации модификатора, которым следует пользоваться всем элементам микса, возможно использование
атрибута "class" - это будет "общак" ;) Не забывайте, что "class" скорей всего используется и другими
фреймворками, потому добавляйте к наименованию модификатора namespace (префикс проекта/организации).

Если необходимо изменить отображение элемента в контексте одного из состояний/view родительского элемента (блока),
то, если есть желание не увеличивать количество атрибутов на элементе, селектор может выглядеть подобным образом:
`*[my-sidebar__caption *= "-my-sidebar::slave-"]`, инчае мы бы написали так: `*[my-sidebar--slave__caption]`.
При острой необходимости я предпочитаю пользоваться первым вариантом, чтобы модификаторы присутствовали только в
атрибутивных значениях отведённых под модификаторы. Но предпочтение отдаю модификаторам элементов,
т.е. предыдущий пример можно упростить до варианта `*[my-sidebar__caption *= -slave-]`

##Состояние
Состояние - сущность-признак отвечающая за отображение элемента и в целом блока (состояние блока задаёт
контекст отображения элементов блока), в отличие от модификаторов, динамически изменяется.
Элемент/контейнер блока может находится сразу в нескольких состояниях.

Состояния, в отличии от модификаторов, могут иметь одни и те же названия в разных блоках и элементах,
уникальность селектора гарантируется за счёт указания имени блока и элемента. Конечно можно описывать
состояния не привязываясь к конкретному блоку, но необходимо помнить, что css-свойства в таком селекторе
скорее всего для конкретного блока прийдётся переопределять.

Использование стандартного способа указания состояния при помощи стандартных
атрибутов или [WAI ARIA](https://www.w3.org/WAI/ARIA/project), таких как disabled, checked, hidden, readonly,
required, aria-busy, aria-expanded, aria-grabbed, aria-invalid, aria-pressed, aria-readonly, aria-required,
aria-selected, приводит к усложнению и увеличению веса селектора.
Дублировать disabled и checked в aria-disabled и aria-checked нет смысла.

Предпочтительней не ориентировать визуальное состояние на ARIA-атрибуты, и размещать наименования состояни
в атрибут Элемента (my-class) в качестве значений, возможно группировать view и state `-viewName--stateName-`.

Селекторы могут выглядеть следующим образом:
```css
/* iAMcss 1.0 */
.my-iTree[role = 'treeitem'][aria-expanded = 'true'] {}
.my-iTreeTooltip[role = 'treeitem']:hover {}

/* iAMcss 2.0 */
*[data-my-tree__item][aria-expanded = 'true'] {}
*[data-my-tree-tooltip]:hover {}
*[data-my-tree-tooltip *= -loading-] {}
```

Необходимо понимать, что составные селекторы наращивают специфичность, старайтесь придерживаться
минимальной специфичности (либо какой-то базовой), чтобы при написании переопределяемого селектора
не приходилось семантически избыточно наращивать специфичность.

###Состояние по умолчанию / undefined

Даже в случае если у вас элемент имеет всего два состояния, рекомендуется прописывать оба,
а не определять оформление элемента по умолчанию + переопределять эти же свойства в контексте
одного из состояний. В качестве исключения можно назвать состояния с использованием стандартизированных
атрибутов `[disabled]` и `[checked]`, управление которыми заключается в их добавлении/удалении.
При наличии модификатора базового состояния, его toggle будет замещать модификатор нового состояния
в предсказуемом месте. В противном случае модификаторы будут как на конвейере перепрописываться в конец
атрибута.
Разумеется любую рекомендацию вы можете игнорировать ;)

##Миксы
[Миксы](https://ru.bem.info/methodology/quick-start/#Микс) возможно реализовать только при помощи
html-атрибутов (или их значений), поскольку каждый DOM-элемент обязан иметь одно конкретное имя
html-тэга, а не множество, тогда как на одном тэге можно разместить большое количество всевозможных
атрибутов, благодаря чему и реализовать микс.

Следует особенно задуматься в тот момент, когда у вас среди селекторов вдруг появляется множественный класс
```css
.my-iTree.my-iTooltip
```
скорей всего вы проектируете что-то не так. Микс подразумевает под собой расположение признаков
(классов или атрибутов) на одной DOM-ноде прежде всего для того, чтобы написать селектор с
одним из этих признаков (семантичное разделение разного функционала), а не с несколькими,
и при том сэкономить на DOM-элементах (предназначенных только для визуального оформления) уменьшив глубину DOM-дерева.

С точки зрения iAMcss, миксы являются аналогом множественного наследования интерфейсов в ООП.
Реализация миксов по iAMcss 1.0 и 2.0 несколько различается: в первом случае это набор iКлассов
в атрибуте "class", во втором случае это набор атрибутов на одной html-ноде.

Поскольку миксы рассматриваются как множественное наследование перечислением интерфейсов, то в идеале,
во избежание коллизий и работы со специфичностью селекторов, селекторы `.iClassA[holder] и iClassB[holder]`
(или `*[class-a__holder]` и `*[class-b__holder]`) не должны определять
одинаковые css-свойства, либо эти блоки не должны быть замиксованы вместе на одной DOM-ноде.
Миксы не рекомендуется использовать для доопределения тех или иных свойств элемента, для этого предназначены модификаторы.

В БЭМе миксы используют для того чтобы отделить общие layout-правила (отвечающие за различные размеры и отступы элементов
внутри контейнера) от оформления контейнера которое зависит от того в каком родительском блоке/элементе он находится.
Смотри уже устаревшие [holder/layout блоки](http://vitaly.harisov.name/article/independent-blocks.html),
которые претерпели изменени в рамках методологии БЭМ. Ныне блок миксуется в качестве элемента другого блока, например (смотри dt):
```html
<dl iam-popup="-wgtCountries-">
	<dt iam-title="-sknDark--lvl_3-" iam-popup__title="spcNormal">Popup title</dt>
	<dd iam-popup__content>Some content</dd>
</dl>
```
```css
*[iam-popup__title *= spcNormal]{
	line-height: 2em;
}
```

##Валидность
Если вы любитель [кнопок-бэйджиков от W3C](https://www.w3.org/QA/Tools/Icons), то наверное знаете,
что стандартом HTML5 допускаются помимо WAI-ARIA и стандартных атрибутов
[data- атрибуты](https://www.w3.org/TR/2014/REC-html5-20141028/dom.html#attr-data-*),
остальные атрибуты считаются инвалидными ;)

Если использовать XHTML или XML, то у вас не будет этого ограничения, и вы не обязаны будете каждый
свой атрибут (да ещё и с префиксом) предварять префиксом data-. Как вариант, можно вообще
игнорировать тот факт, что код у вас не совсем валидный, и для удобочитаемости [опускать
префиксы data-](https://habrahabr.ru/post/139210/#comment_4652461). Только необходимо помнить о том,
что вы работаете в глобальном пространстве имён, и, чтобы случайно не пересечься с каким-либо сторонним
фреймворком, его необходимо сужать введением своих префиксов (например проекта/организации).

##JS-хуки.
Для получения необходимого объекта вместо getElementById вызывайте querySelectorAll с заранее известной DOM-ноды,
чтобы сузить область срабатывания селектора. Используйте селектор `*[iam-classname *= wgtId]`.

Параметр для querySelectorAll не должен быть
динамически собираемым, чтобы ваш код легко был распознан верстальщиком. Верстальщик при
изменении селекторов в CSS-файлах обязан также проверять и JS код на наличие CSS-подобных
селекторов в querySelectarAll, потому для JS не требуется заводить дублирующий data-атрибут,
который в других методологиях призван отделить работу js от представления.
Сам же JS-код не должен менять стили программно, он обязан только управлять сменой
[состояний](#Состояние) элемента/блока.

##Префиксы
Валидными custom атрибутами считаются те, что начинаются с префиксов "data-" и "x-".
Если так важна валидность используйте автоматизирующие вашу работу инструменты.
Можно не возвеличивать валидность и в качестве префиксов атрибутов использовать свои наименования.

##Каскадирование и контекст
В целом каскад [не одобряется](https://ru.bem.info/faq/#Почему-нежелательно-использовать-вложенные-селекторы),
хотя бы потому, что вам самим неудобно работать с селекторами
сторонних фреймворков, которые переопределяют оформление вашего элемента. Но если вам
уж сильно не хочется на каждый li и td вешать атрибуты/классы вашего элемента/блока, то
в случае со списком вместо `.my-iList li` предпочтите запись `.my-iList > li` выставив
класс на каждый ul/ol/dl, но помните, когда вам потом понадобится управлять самим li,
вы будете иметь на него влияние ранее написанного каскадного селектора, и в сложных случаях
селекторы [могут ломаться](https://habrahabr.ru/post/270075/#comment_8641367) из-за появления промежуточных dom-элементов.
Случай с таблицей особенный, по идее времена, когда верстали вложенные таблицы прошли
(теперь семантично верстают вложенными списками ;)) и можно вполне допустить использование `.my-iTable td`,
но лучше `.my-iTable__row > td`. Если вешать атрибуты, чтобы привязать оформление на каждую ячейку, то по iAMcss 1.0
плучили бы следующий селектор: `.my-iTable[data-cell]`

Если мы хотим использовать стандартные контролы и не прописывать всё поведение с нуля
(например свои чекбоксы с состояниями disabled, checked), то никуда не деться от повышения
специфичности селектора. Написание кода по iAMcss не должно противоречить современным техникам,
например таким как [css3 checkbox/radio hack](Если мы хотим использовать стандартные контролы и не прописывать всё поведение с нуля
(например свои чекбоксы с состояниями disabled)).

Каскад `.class1 .class2` (через пробел) оправдан только для работы с контекстом состояния родительского
элемента, но при том рекомендуется чтобы `.class2` являлся атрибутивным селектором iAMcss.
Если вы вынуждены громоздить такие цепочки только с целью повысить специфичность
селектора (перекрыть стили от фреймворка например), то значит уже что-то в вашем коде не так,
и вам лучше создать новый элемент (например как в [случае с iam-star](http://codepen.io/viT-1/pen/GrBwbE)).

Для наглядности каждую часть каскадного селектора следует писать на новой строке, все кроме первой строки начинать с пробела. [Пример](http://codepen.io/viT-1/pen/GrBwbE).

##Преимущества и недостатки версий iAMcss 1.0 и 2.0
В iAMcss 1.0 проще работать со стандартными атрибутами (в т.ч. ARIA), так как можно опираться
на них как есть, помечая свои "блоки" классом. Также, в случае миксов, для написания селекторов
можно пользоваться одними и теми же атрибутами (как своими, так и стандартными). С одной стороны
такой подход сокращает количество атрибутов на DOM-элементе, а с другой стороны не далеко уходит
от стилистики маркировки элементов до БЭМа - всё в class.

Конструкция `.iParentName[child-name]` более специфична чем `*[parent-name__child-name]`,
к тому же в iAMcss именования расположены в разных атрибутах (class и my-custom-attr), что добавляет путанницы.
Контекстные селекторы повышают специфичность, потому `.iParentName > .iChildName` не выход.
Эта проблема особенно актуальна для эволюционировавшей идеи holder-блоков: когда вы начинаете
[выносить оформление элемента, которое может быть различным](https://ru.bem.info/forum/656/)
и зависит от того в каком родительском элементе он находится.

iAMcss 1.0 эволюционировал в iAMcss 2.0 только по одной причине: каждый модификатор элемента должен
относится к конкретному блоку, потому пришлось перенести именование блока из атрибута "class"
в префикс атрибута относящегося к элементу. Если у вас есть необходимость чётко
разделять элементы и их модификаторы разных блок-интерфейсов по разным атрибутам, то пользуйтесь
нотацией iAMcss 2.0.

В iAMcss 2.0 самое главное ограничение внешнее: названия атрибутов обязаны быть написаны
в нижнем регистре. Соответственно [Венгерскю нотацию](https://ru.wikipedia.org/wiki/%D0%92%D0%B5%D0%BD%D0%B3%D0%B5%D1%80%D1%81%D0%BA%D0%B0%D1%8F_%D0%BD%D0%BE%D1%82%D0%B0%D1%86%D0%B8%D1%8F)
использовать можно только для сложных наименований модификаторов.

В iAMcss 2.0 позволяется использовать атрибут "class" для размещения глобальных модификаторов,
например `.-my-animated-`, соответственно можно использовать для нескольких блоков расположенных
на одном DOM-элементе единые состояния, которые, впрочем, можно перенести и в отдельные атрибуты.
Нужно помнить, что использование любых селекторов поверх `*[attr]` или `*[attr *= val]` увеличивает
их вес, что может привести к сложностям их переопределения.

##Примеры кода
- Сравнительная вёрстка [БЭМ, iAMcss 1.0 и iAMcss 2.0](http://codepen.io/viT-1/pen/RKbXwE) (2017.02.15)
- Сложный [микс кнопки и выпадающего списка](http://codepen.io/viT-1/pen/VjXybd) по iAMcss 1.0 (2016.12.08)
- [FontAwesome чекбоксы/радио-кнопки](http://codepen.io/viT-1/pen/GrBwbE) с применением iAMcss 2.0 и поддержкой клавиатуры (2017.02.15)
- [Применение стандартных атрибутов и checkbox-hack](https://codepen.io/viT-1/pen/KXyyGM) в соседстве с ARIA-атрибутами, сложные селекторы с применением iAMcss 2.0 (2017.10.09)
- [Виджет vp-tree__list JSON](https://codepen.io/viT-1/pen/XVxEgX) по iAMcss 2.0 и SVG-иконками разных размеров (2018.01.18)
- [Виджет vp-tree__list XSLT + IE8](https://vit-1.github.io/iAMcss/samples/tree/list.xml) (2018.01.24)